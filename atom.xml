<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LP&#39;s Notes</title>
  
  <subtitle>侠客行舟 不进则退</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lpnote.com/"/>
  <updated>2019-02-13T08:59:06.532Z</updated>
  <id>http://www.lpnote.com/</id>
  
  <author>
    <name>LPNOTE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elasticsearch中ignore_above的作用</title>
    <link href="http://www.lpnote.com/2019/02/13/ignore_above-in-elasticsearch/"/>
    <id>http://www.lpnote.com/2019/02/13/ignore_above-in-elasticsearch/</id>
    <published>2019-02-13T08:57:50.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<p>ignore_above一般配合keyword类型使用，指示该字段的最大索引长度（即超过该长度的内容将不会被索引），对于超过ignore_above长度的字符串，analyzer不会进行索引分析，所以超过该长度的内容将不会被搜索到。这个选项主要对not_analyzed字段有用，这些字段通常用来进行过滤、聚合和排序。而且这些字段都是整体存在的，不需要进行索引分析处理，所以一般不会允许在这些字段中索引过长的项。</p><p>当在设置索引的mapping设置后，如果keyword字段没有显式设置ignore_above的值，则ES会默认设置该长度为256，当然你可以在后续的操作中修改这个值，但是修改后需要重建索引才能让以前不满足的值重新变得满足而被索引。</p><ol><li>不满足该设置的文档会被保存，但是该字段值不会被索引</li><li>通过查询该字段的值时该文档不会被索引到，并被输出</li><li>通过其它字段的查询时，如果该文档满足条件会被索引到，并被输出</li><li>该设置选项并不影响文档的保存，只影响文档的字段是否被索引和搜索</li></ol><p>注：keyword类型的字段的最大长度限制为32766个UTF-8字符，text类型的字段对字符长度没有限制</p><p>所以在设置keyword类型的ignore_above值时应该先遵守keyword本身的值最大长度限制。</p><blockquote><p>ignore_above 值表示字符个数，但是 Lucene 计算的是字节数。如果你使用包含很多非 ASCII 字符的 UTF-8 文本，你应该将这个限制设置成 32766 / 3 = 10922 因为 UTF-8 字符可能最多占用 3 个字节。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ignore_above一般配合keyword类型使用，指示该字段的最大索引长度（即超过该长度的内容将不会被索引），对于超过ignore_above长度的字符串，analyzer不会进行索引分析，所以超过该长度的内容将不会被搜索到。这个选项主要对not_analyzed字段
      
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="搜索引擎" scheme="http://www.lpnote.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="lucene" scheme="http://www.lpnote.com/tags/lucene/"/>
    
      <category term="elasticsearch" scheme="http://www.lpnote.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>java并发之Striped64解析</title>
    <link href="http://www.lpnote.com/2019/02/02/java-concurrent-striped64/"/>
    <id>http://www.lpnote.com/2019/02/02/java-concurrent-striped64/</id>
    <published>2019-02-02T08:42:44.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文基于JDK1.8进行解析，其它JDK版本可能有所不同。</p><p>早在JDK1.5的时候就已经引入了大神Doug Lea的并发包体系，其中包括各种显式锁及实现，原子类，原子引用等，极大的丰富了JDK的并发生态。让我们实现数据同步从“原始社会”的synchroinzed阶段一下子过度到了基于CAS的“现代社会”，JDK1.5的AQS堪称当代并发的一个神器级的工具，然而追求永远是无穷尽的，当人们在享受到原子类带来的性能提升的时候，大神Doug Lea又一次为原子操作的Long和Double带来新的成员：Striped64及它的子类。它的原理相对来说比较简单，也是JDK常用的方式，就是通过CAS以及“分段技术”努力地减少争用，尽最大可能提高并发度。</p><p>Striped64该类维护了一个惰性初始化的列表和一个基础(base)的数值，列表的大小是2的次方，索引这个列表是通过基于每个线程的内部Probe算出一个Hashcode来确定。这个类的几乎所有的方法都是protected的，所以只有它的子类可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Striped64</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">  <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bound on table size */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment">     * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating Cells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    .... 相关方法省略</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; sk = Striped64.class;</span><br><span class="line">            BASE = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"base"</span>));</span><br><span class="line">            CELLSBUSY = UNSAFE.objectFieldOffset</span><br><span class="line">                (sk.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类一个包本地类，只能在包范围内引用，包含支持64位值动态分段的类的通用表示和机制。该类同时继承至Number，因此具体的子类必须实现其接口方法。</p><p>在Striped64内部，持有数据的是一个由叫做Cell的数据结构的一个列表实现，这个Cell数据结构通过使用@sun.misc.Contented这个注解来减少缓存行冲突，关于缓存冲突，缓存行，伪共享的描述可以参看相关资料。通常情况下，缓存行填充(Padding)对于大多数原子操作来说都是不必要的，因为它们散落在不规则的内存中。但是对于存在于一个数组内的原子对象来说，这样的情况会发生变化，它们会产生相互影响，原因是因为它们在内存中的布局会相互紧挨着，并存在大量的共享相同的缓存行，而共享缓存行对于性能的影响将是非常巨大的。</p><p>相对来说Cell这个结构还是比较大的，所以我们尽量避免提前创建它们，除非在真正用到它们的时候。当没有竞争时，所有的更新操作都会应用到base字段上。当第一次产生争用时（在base字段上发生CAS失败），这个列表会被初始化，初始化大小为2。当后续仍然产生争用时，这个列表会被进一步扩展（除非到达了它的终极大小限制：列表大小的扩展到和CPU数量相当），列表中的Slot是空的，只有在使用它的时候才进行初始化。</p><p>一个自旋锁cellsBusy被用于列表的初始化和扩容，以及Slot的填充。在这里没有必要使用阻塞，当锁不可用时，线程会尝试获取其它Slot的锁（或者尝试base字段）。在这些重试期间，争用是增加了但局部性争用是降低了，这仍然比替代方案更好。</p><p>通过ThreadLocalRandom维护的Thread probe字段用作每线程哈希码。在未产生争用时，我们让它保持未初始化的值为0。当初始化时尽量保证这个值不与其它线程的值相冲突。执行更新操作时，失败的CAS会指示争用或列表冲突。当发生冲突时，如果此时列表的大小还没有达到极限大小限制，列表会进行扩容除非有其它的线程持有这把锁。如果被hashcode指定索引到的slot为空，并且锁是可用的，那么这个slot会被初始化为一个新的Cell。其它情况下，如果slot中存在Cell，那么就执行一次CAS操作来更新Cell中的值。重试通过“双重散列”进行，使用辅助散列（Marsaglia XorShift）尝试查找空闲插槽。</p><p>列表大小是有限的，因为当线程多于CPU时，假设每个线程都绑定到CPU，就会存在一个完美的哈希函数，将线程映射到槽以消除冲突。 当我们达到容量时，我们通过随机改变冲突线程的哈希码来搜索此映射。 因为搜索是随机的，并且冲突仅通过CAS失败而变得已知，所以收敛可能很慢，并且因为线程通常不会永远地绑定到CPUS，所以可能根本不会发生。 然而，尽管存在这些限制，但在这些情况下观察到的争用率通常较低。</p><p>当曾经散列到它的线程终止时，以及在列表扩容导致没有线程在扩展掩码下散列到它的情况下，Cell可能会被释放。我们不会尝试检测或删除此类Cell，假设对于长期运行的实例，观察到的争用情况可能会再次出现，因此最终将再次需要Cell; 对于短命的实例来说，没关系，GC帮我们清理这整个实例。</p><p>在整个实现过程中大量使用CAS无锁操作，并运用Padding技术（缓存行填充）将一个原子化的Long操作性能发挥到极致，在普通无争用或者争用较少的情况下，可以用base以及少量的Cell就可以动态减少争用，并在争用激烈时通过扩容Cell列表的方式来分散争用。这种模式有点类似分段锁的方式，不同的是这种实现更高效，全程无锁无阻塞。</p><p>Striped64类使用一个base和一个分散的Cell列表来实现对于Long型数值的操作，其核心的方法为longAccumulate和doubleAccumulate，其中这两个方法思路和模式均相同，只是一个针对于long类型，一个针对double类型。</p><p>关于对longAccumulate方法的解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       </span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该类还有几个子类，通常我们在使用的时候一般会使用到的就是它的子类，包括：LongAdder，LongAccumulator，DoubleAdder，DoubleAccumulator，其中LongAdder和LongAccumulator只存在细微差异，Adder故名思意是求和的意思，LongAdder是指多次调用累加求和。而LongAccumulator是累积计算的意思，累积计算就不一定是求和了，也有可能是其它操作，这里它提供了一个二元操作接口了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this operator to the given operands.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left the first operand</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right the second operand</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operator result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于控制在这个累积器中应该如何对long类数据进行操作。在Striped64的longAccumulate方法中我们也看到了LongBinaryOperator作为了参数传入，并在更新值时进行了计算，只是默认在传null的情况下，默认为累加，这也是LongAdder实现累加的原理：</p><p>LongAdder类累加方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>DoubleAdder和DoubleAccumuator同LongAdder和LongAccumulator，这里不再累述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：本文基于JDK1.8进行解析，其它JDK版本可能有所不同。&lt;/p&gt;
&lt;p&gt;早在JDK1.5的时候就已经引入了大神Doug Lea的并发包体系，其中包括各种显式锁及实现，原子类，原子引用等，极大的丰富了JDK的并发生态。让我们实现数据同步从“原始社会”的synchroin
      
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
      <category term="多线程" scheme="http://www.lpnote.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://www.lpnote.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一次Skywalking内存泄露的原因分析</title>
    <link href="http://www.lpnote.com/2019/01/31/memory-leak-analysis-for-skywalking/"/>
    <id>http://www.lpnote.com/2019/01/31/memory-leak-analysis-for-skywalking/</id>
    <published>2019-01-31T03:21:57.000Z</published>
    <updated>2019-02-13T08:59:06.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是skywalking"><a href="#什么是skywalking" class="headerlink" title="什么是skywalking"></a>什么是skywalking</h1><p>Skywalking 是一款分布式系统的应用程序性能监视工具(APM)，专为微服务、云本机架构和基于容器（Docker、K8s、Mesos）架构而设计。</p><p>详细的Skywalking介绍见：<a href="http://skywalkking.apache.org" target="_blank" rel="noopener">Skywalking官网</a></p><h1 id="遇到的问题场景"><a href="#遇到的问题场景" class="headerlink" title="遇到的问题场景"></a>遇到的问题场景</h1><ol><li>公司Dev/Test环境</li><li>Collector因故宕机很长时间，约两周（无人维护监控）</li><li>应用接入端agent内存暴涨导致大量应用内存溢出或告警</li><li>Skywalking版本：5.0.0-GA<a id="more"></a></li></ol><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">2018</span>-<span class="number">12</span>-<span class="number">03</span> <span class="number">09</span>:<span class="number">50</span>:<span class="number">47</span>:<span class="number">931</span> AppAndServiceRegisterClient :  AppAndServiceRegisterClient execute fail.</span><br><span class="line">org.apache.skywalking.apm.dependencies.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:<span class="number">222</span>)</span><br></pre></td></tr></table></figure><p>另一些应用报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">2019</span>-<span class="number">01</span>-<span class="number">20</span> <span class="number">20</span>:<span class="number">44</span>:<span class="number">21</span>:<span class="number">024</span> JVMService :  send JVM metrics to Collector fail. </span><br><span class="line">org.apache.skywalking.apm.dependencies.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.grpc.stub.ClientCalls.toStatusRuntimeException(ClientCalls.java:<span class="number">222</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.grpc.stub.ClientCalls.getUnchecked(ClientCalls.java:<span class="number">203</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.grpc.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:<span class="number">132</span>)</span><br><span class="line">        at org.apache.skywalking.apm.network.proto.JVMMetricsServiceGrpc$JVMMetricsServiceBlockingStub.collect(JVMMetricsServiceGrpc.java:<span class="number">158</span>)</span><br><span class="line">        at org.apache.skywalking.apm.agent.core.jvm.JVMService$Sender.run(JVMService.java:<span class="number">143</span>)</span><br><span class="line">        at org.apache.skywalking.apm.util.RunnableWithExceptionProtection.run(RunnableWithExceptionProtection.java:<span class="number">36</span>)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:<span class="number">308</span>)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$<span class="number">301</span>(ScheduledThreadPoolExecutor.java:<span class="number">180</span>)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:<span class="number">294</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">Caused by: org.apache.skywalking.apm.dependencies.io.netty.channel.AbstractChannel$AnnotatedConnectException: 拒绝连接: /<span class="number">172.21</span>.16.175:<span class="number">11800</span></span><br><span class="line">        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)</span><br><span class="line">        at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:<span class="number">717</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:<span class="number">325</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:<span class="number">340</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:<span class="number">634</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:<span class="number">581</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:<span class="number">498</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:<span class="number">460</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.util.concurrent.SingleThreadEventExecutor$<span class="number">5</span>.run(SingleThreadEventExecutor.java:<span class="number">884</span>)</span><br><span class="line">        at org.apache.skywalking.apm.dependencies.io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:<span class="number">30</span>)</span><br><span class="line">        ... <span class="number">1</span> more</span><br><span class="line">Caused by: java.net.ConnectException: 拒绝连接</span><br><span class="line">        ... <span class="number">11</span> more</span><br></pre></td></tr></table></figure><p>这些日志大量出现在应用日志中，从发生内存溢出以前很久时间一直持续。</p><p>通过jmap将java内存对象状态dump出来分析：</p><p><img src="https://i.loli.net/2019/01/31/5c52660b1228b.png" alt="image.png"></p><p>发现存在大量skywalking对象占据内存，具体对象为：HpackHeaderField和ManagedChannelImpl。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>HpackHeaderField和ManagedChannelImpl均为处理gRPC的处理类，并根据内存泄露时报的错误来看，Collector挂掉了很久，一直在重试连接。查看skywalking的源码分析重连过程：</p><p>GRPCChannelManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"Selected collector grpc service running, reconnect:&#123;&#125;."</span>, reconnect);</span><br><span class="line">        <span class="keyword">if</span> (reconnect) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RemoteDownstreamConfig.Collector.GRPC_SERVERS.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String server = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = Math.abs(random.nextInt()) % RemoteDownstreamConfig.Collector.GRPC_SERVERS.size();</span><br><span class="line">                    server = RemoteDownstreamConfig.Collector.GRPC_SERVERS.get(index);</span><br><span class="line">                    String[] ipAndPort = server.split(<span class="string">":"</span>);</span><br><span class="line">                    managedChannel = GRPCChannel.newBuilder(ipAndPort[<span class="number">0</span>], Integer.parseInt(ipAndPort[<span class="number">1</span>]))</span><br><span class="line">                        .addManagedChannelBuilder(<span class="keyword">new</span> StandardChannelBuilder())</span><br><span class="line">                        .addManagedChannelBuilder(<span class="keyword">new</span> TLSChannelBuilder())</span><br><span class="line">                        .addChannelDecorator(<span class="keyword">new</span> AuthenticationDecorator())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!managedChannel.isShutdown() &amp;&amp; !managedChannel.isTerminated()) &#123;</span><br><span class="line">                        reconnect = <span class="keyword">false</span>;</span><br><span class="line">                        notify(GRPCChannelStatus.CONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        notify(GRPCChannelStatus.DISCONNECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(t, <span class="string">"Create channel to &#123;&#125; fail."</span>, server);</span><br><span class="line">                    notify(GRPCChannelStatus.DISCONNECT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">"Selected collector grpc service is not available. Wait &#123;&#125; seconds to retry"</span>, Config.Collector.GRPC_CHANNEL_CHECK_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可知，当collector挂掉后，agent在尝试重连而一直连接不上时，会不断的创建ManagedChannel对象，查看gRPC的ManagedChannelOrphanWrapper源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagedChannelOrphanWrapper</span> <span class="keyword">extends</span> <span class="title">ForwardingManagedChannel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;ManagedChannelOrphanWrapper&gt; refqueue =</span><br><span class="line">      <span class="keyword">new</span> ReferenceQueue&lt;ManagedChannelOrphanWrapper&gt;();</span><br><span class="line">  <span class="comment">// Retain the References so they don't get GC'd</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;ManagedChannelReference, ManagedChannelReference&gt; refs =</span><br><span class="line">      <span class="keyword">new</span> ConcurrentHashMap&lt;ManagedChannelReference, ManagedChannelReference&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger =</span><br><span class="line">      Logger.getLogger(ManagedChannelOrphanWrapper.class.getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ManagedChannelReference phantom;</span><br><span class="line"></span><br><span class="line">  ManagedChannelOrphanWrapper(ManagedChannel delegate) &#123;</span><br><span class="line">    <span class="keyword">this</span>(delegate, refqueue, refs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">... 此后代码省略</span><br></pre></td></tr></table></figure><p>上面有一句话明确提示：Retain the References so they don’t get GC’d<br>同时也初始化了一些Netty相关的处理类，并且没有释放。</p><p>翻看了一些gRPC的文档，也是建议一定要显式的关闭channel。</p><p>修改了agent部分的源码，处理为在重连时关闭旧的Channel对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"Selected collector grpc service running, reconnect:&#123;&#125;."</span>, reconnect);</span><br><span class="line">        <span class="keyword">if</span> (reconnect) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RemoteDownstreamConfig.Collector.GRPC_SERVERS.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String server = <span class="string">""</span>;</span><br><span class="line">                GRPCChannel oldChannel = managedChannel;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = Math.abs(random.nextInt()) % RemoteDownstreamConfig.Collector.GRPC_SERVERS.size();</span><br><span class="line">                    server = RemoteDownstreamConfig.Collector.GRPC_SERVERS.get(index);</span><br><span class="line">                    String[] ipAndPort = server.split(<span class="string">":"</span>);</span><br><span class="line">                    managedChannel = GRPCChannel.newBuilder(ipAndPort[<span class="number">0</span>], Integer.parseInt(ipAndPort[<span class="number">1</span>]))</span><br><span class="line">                        .addManagedChannelBuilder(<span class="keyword">new</span> StandardChannelBuilder())</span><br><span class="line">                        .addManagedChannelBuilder(<span class="keyword">new</span> TLSChannelBuilder())</span><br><span class="line">                        .addChannelDecorator(<span class="keyword">new</span> AuthenticationDecorator())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!managedChannel.isShutdown() &amp;&amp; !managedChannel.isTerminated()) &#123;</span><br><span class="line">                        reconnect = <span class="keyword">false</span>;</span><br><span class="line">                        notify(GRPCChannelStatus.CONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        notify(GRPCChannelStatus.DISCONNECT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(t, <span class="string">"Create channel to &#123;&#125; fail."</span>, server);</span><br><span class="line">                    notify(GRPCChannelStatus.DISCONNECT);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oldChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        oldChannel.shutdownNow();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">"Selected collector grpc service is not available. Wait &#123;&#125; seconds to retry"</span>, Config.Collector.GRPC_CHANNEL_CHECK_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打包推送至Dev环境进行观察，同时也模拟Collector的情况将Collector杀死。经过一段时间的观察，内存平稳无异常。</p><p>到此skywalking的特定情况下的内存泄漏问题得到解决，相关issue已由同事提交到skywalking官方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是skywalking&quot;&gt;&lt;a href=&quot;#什么是skywalking&quot; class=&quot;headerlink&quot; title=&quot;什么是skywalking&quot;&gt;&lt;/a&gt;什么是skywalking&lt;/h1&gt;&lt;p&gt;Skywalking 是一款分布式系统的应用程序性能监视工具(APM)，专为微服务、云本机架构和基于容器（Docker、K8s、Mesos）架构而设计。&lt;/p&gt;
&lt;p&gt;详细的Skywalking介绍见：&lt;a href=&quot;http://skywalkking.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Skywalking官网&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;遇到的问题场景&quot;&gt;&lt;a href=&quot;#遇到的问题场景&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题场景&quot;&gt;&lt;/a&gt;遇到的问题场景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;公司Dev/Test环境&lt;/li&gt;
&lt;li&gt;Collector因故宕机很长时间，约两周（无人维护监控）&lt;/li&gt;
&lt;li&gt;应用接入端agent内存暴涨导致大量应用内存溢出或告警&lt;/li&gt;
&lt;li&gt;Skywalking版本：5.0.0-GA
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="问题解析" scheme="http://www.lpnote.com/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
      <category term="参与开源" scheme="http://www.lpnote.com/tags/%E5%8F%82%E4%B8%8E%E5%BC%80%E6%BA%90/"/>
    
      <category term="skywalking" scheme="http://www.lpnote.com/tags/skywalking/"/>
    
      <category term="apm" scheme="http://www.lpnote.com/tags/apm/"/>
    
  </entry>
  
  <entry>
    <title>合并写(write combining)</title>
    <link href="http://www.lpnote.com/2019/01/31/write-combining/"/>
    <id>http://www.lpnote.com/2019/01/31/write-combining/</id>
    <published>2019-01-31T02:46:33.000Z</published>
    <updated>2019-02-13T08:59:06.552Z</updated>
    
    <content type="html"><![CDATA[<p><strong>转载自并发编程网 – ifeve.com 本文链接地址: <a href="http://ifeve.com/writecombining/" target="_blank" rel="noopener">合并写(write combining)</a> 译者：无叶 校对：丁一</strong></p><p>现代CPU采用了大量的技术来抵消内存访问带来的延迟。读写内存数据期间，CPU能执行成百上千条指令。</p><p>多级SRAM缓存是减小这种延迟带来的影响的主要手段。此外，SMP系统采用消息传递协议来实现缓存之间的一致性。遗憾的是，现代的CPU实在是太快了，即使是使用了缓存，有时也无法跟上CPU的速度。因此，为了进一步减小延迟的影响，一些鲜为人知的缓冲区派上了用场。</p><p>本文将探讨“合并写存储缓冲区（write combining store buffers）”，以及如何写出有效利用它们的代码。</p><p>CPU缓存是一种高效的非链式结构的hash map，每个桶（bucket）通常是64个字节。这就是一个“缓存行（cache line）”。缓存行是内存交换的实际单位。例如，主存中地址A会映射到一个给定的缓存行C。</p><p>如果CPU需要访问的地址hash后的行尚不在缓存中，那么缓存中对应位置的缓存行会被清除，以便载入新的行。例如，如果我们有两个地址，通过hash算法hash到同一缓存行，那么新的值会覆盖老的值。</p><p>当CPU执行存储指令（store）时，它会尝试将数据写到离CPU最近的L1缓存。如果此时出现缓存未命中，CPU会访问下一级缓存。此时，无论是英特尔还是许多其它厂商的CPU都会使用一种称为“合并写（write combining）”的技术。</p><p>在请求L2缓存行的所有权尚未完成时，待存储的数据被写到处理器自身的众多跟缓存行一样大小的存储缓冲区之一。这些芯片上的缓冲区允许CPU在缓存子系统未准备好接收和处理数据时继续执行指令。当数据不在任何其它级别的缓存中时，将获得最大的优势。</p><p>当后续的写操作需要修改相同的缓存行时，这些缓冲区变得非常有趣。在将后续的写操作提交到L2缓存之前，可以进行缓冲区写合并。 这些64字节的缓冲区维护了一个64位的字段，每更新一个字节就会设置对应的位，来表示将缓冲区交换到外部缓存时哪些数据是有效的。</p><p>也许你要问，如果程序要读取已被写入缓冲区的某些数据，会怎么样？我们的硬件工程师已经考虑到了这点，在读取缓存之前会先去读取缓冲区的。</p><p>这一切对我们的程序意味着什么？</p><p>如果我们能在缓冲区被传输到外部缓存之前将其填满，那么将大大提高各级传输总线的效率。如何才能做到这一点呢？好的程序将大部分时间花在循环处理任务上。</p><p>这些缓冲区的数量是有限的，且随CPU模型而异。例如在Intel CPU中，同一时刻只能拿到4个。这意味着，在一个循环中，你不应该同时写超过4个不同的内存位置，否则你将不能享受到合并写（write combining）的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    ITEMS      = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    MASK       = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF     = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            out.println(i + <span class="string">" SplitLoop duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arrayA[<span class="number">1</span>] + arrayB[<span class="number">2</span>] + arrayC[<span class="number">3</span>] + arrayD[<span class="number">4</span>] + arrayE[<span class="number">5</span>] + arrayF[<span class="number">6</span>];</span><br><span class="line">        out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序在我的Windows 7 64位英特尔酷睿<a href="mailto:i7860@2.8" target="_blank" rel="noopener">i7860@2.8</a> GHz系统上产生的输出如下：</p><blockquote><p>1 SingleLoop duration (ns) = 14019753545<br> 1 SplitLoop  duration (ns) = 8972368661<br> 2 SingleLoop duration (ns) = 14162455066<br> 2 SplitLoop  duration (ns) = 8887610558<br> 3 SingleLoop duration (ns) = 13800914725<br> 3 SplitLoop  duration (ns) = 7271752889</p></blockquote><p>上面的例子说明：如果在一个循环中修改6个数组位置（内存地址），程序的运行时间明显长于将任务拆分的方式，即，先写前3个位置，再修改后3个位置。</p><p>通过拆分循环，我们做了更多的工作，但程序花费的时间更少！欢迎利用神奇的“合并写（write combining）”。通过使用CPU架构的知识，正确的填充这些缓冲区，我们可以利用底层硬件加速我们的程序。</p><p>不要忘了超线程（hyper-threading），可能会有2个线程竞争同一个核的缓冲区。</p><p>转载自并发编程网 – ifeve.com 本文链接地址: <a href="http://ifeve.com/writecombining/" target="_blank" rel="noopener">合并写(write combining)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;转载自并发编程网 – ifeve.com 本文链接地址: &lt;a href=&quot;http://ifeve.com/writecombining/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并写(write combining)&lt;/a&gt; 译
      
    
    </summary>
    
      <category term="转载文章" scheme="http://www.lpnote.com/categories/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
      <category term="多线程" scheme="http://www.lpnote.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://www.lpnote.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>伪共享(False Sharing)</title>
    <link href="http://www.lpnote.com/2019/01/31/false-sharing/"/>
    <id>http://www.lpnote.com/2019/01/31/false-sharing/</id>
    <published>2019-01-31T02:27:31.000Z</published>
    <updated>2019-02-13T08:59:06.524Z</updated>
    
    <content type="html"><![CDATA[<p>转载自并发编程网 – ifeve.com 本文链接地址: <a href="伪共享(False Sharing">伪共享</a>)</p><p><strong>原文地址：<a href="http://ifeve.com/false-sharing/" target="_blank" rel="noopener">http://ifeve.com/false-sharing/</a></strong></p><p><strong>作者：Martin Thompson  译者：丁一</strong></p><p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p><p>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解内存布局，或找个工具告诉我们。Intel VTune就是这样一个分析工具。本文中我将解释Java对象的内存布局以及我们该如何填充缓存行以避免伪共享。</p><a id="more"></a><p><img src="https://i.loli.net/2019/01/31/5c525b69739f4.png" alt="image.png"></p><p>图1说明了伪共享的问题。在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p><h2 id="Java内存布局-Java-Memory-Layout"><a href="#Java内存布局-Java-Memory-Layout" class="headerlink" title="Java内存布局(Java Memory Layout)"></a>Java内存布局(Java Memory Layout)</h2><p>对于HotSpot JVM，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位（如锁的状态或作为锁对象）组成的Mark Word。第二个字是对象所属类的引用。如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。因此当封装对象的时候为了高效率，对象字段声明的顺序会被重排序成下列基于字节大小的顺序：</p><ol><li>doubles (8) 和 longs (8)</li><li>ints (4) 和 floats (4)</li><li>shorts (2) 和 chars (2)</li><li>booleans (1) 和 bytes (1)</li><li>references (4/8)</li><li>&lt;子类字段重复上述顺序&gt;<br>（译注：更多HotSpot虚拟机对象结构相关内容:<a href="http://www.infoq.com/cn/articles/jvm-hotspot）" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/jvm-hotspot）</a></li></ol><p>了解这些之后就可以在任意字段间用7个long来填充缓存行。在Disruptor里我们对RingBuffer的cursor和BatchEventProcessor的序列进行了缓存行填充。</p><p>为了展示其性能影响，我们启动几个线程，每个都更新它自己独立的计数器。计数器是volatile long类型的，所以其它线程能看到它们的进展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>; <span class="comment">// change</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> arrayIndex;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> VolatileLong[] longs = <span class="keyword">new</span> VolatileLong[NUM_THREADS];</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> VolatileLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        runTest();</span><br><span class="line">        System.out.println(<span class="string">"duration = "</span> + (System.nanoTime() - start));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads)</span><br><span class="line">        &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads)</span><br><span class="line">        &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i)</span><br><span class="line">        &#123;</span><br><span class="line">            longs[arrayIndex].value = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileLong</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// comment out</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果-Results"><a href="#结果-Results" class="headerlink" title="结果(Results)"></a>结果(Results)</h2><p>运行上面的代码，增加线程数以及添加/移除缓存行的填充，下面的图2描述了我得到的结果。这是在我4核Nehalem上测得的运行时间。</p><p><img src="https://i.loli.net/2019/01/31/5c525ca7d0a59.png" alt="image.png"></p><p>从不断上升的测试所需时间中能够明显看出伪共享的影响。没有缓存行竞争时，我们几近达到了随着线程数的线性扩展。</p><p>这并不是个完美的测试，因为我们不能确定这些VolatileLong会布局在内存的什么位置。它们是独立的对象。但是经验告诉我们同一时间分配的对象趋向集中于一块。</p><p>所以你也看到了，伪共享可能是无声的性能杀手。</p><p>转载自并发编程网 – ifeve.com 本文链接地址: <a href="伪共享(False Sharing">伪共享</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自并发编程网 – ifeve.com 本文链接地址: &lt;a href=&quot;伪共享(False Sharing&quot;&gt;伪共享&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址：&lt;a href=&quot;http://ifeve.com/false-sharing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ifeve.com/false-sharing/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者：Martin Thompson  译者：丁一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。&lt;/p&gt;
&lt;p&gt;为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解内存布局，或找个工具告诉我们。Intel VTune就是这样一个分析工具。本文中我将解释Java对象的内存布局以及我们该如何填充缓存行以避免伪共享。&lt;/p&gt;
    
    </summary>
    
      <category term="转载文章" scheme="http://www.lpnote.com/categories/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
      <category term="多线程" scheme="http://www.lpnote.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://www.lpnote.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>groovy-expr-usage</title>
    <link href="http://www.lpnote.com/2019/01/08/groovy-expr-usage/"/>
    <id>http://www.lpnote.com/2019/01/08/groovy-expr-usage/</id>
    <published>2019-01-08T11:23:32.000Z</published>
    <updated>2019-02-13T08:59:06.528Z</updated>
    
    <content type="html"><![CDATA[<p>在开发单据规则计算引擎的时候引入了groovy脚本计算引擎，其中有一个规则函数：正则函数需要使用正则表达式计算，顺便找了一下groovy里的正则表达式：</p><p>groovy中对于正则表达式的书写进行了简化，同时它仍然是引用的java核心的正则表达式引擎，并没有自己实现一套正则引擎，更多的是从语法糖的形式上进行优化，让人使用起来格外的舒服。</p><ul><li>查找（find）操作符：=~  返回Matcher类型</li><li>匹配（match）操作符：==~  返回boolean类型</li><li>模式(pattern)操作符：~String  返回Pattern类型</li></ul><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprCheck</span> <span class="keyword">implements</span> <span class="title">FunctionInvoke</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> EXPR_PARAM = <span class="string">"expr"</span>;</span><br><span class="line"></span><br><span class="line">    FunctionResult invoke(FunctionContext ctx) &#123;</span><br><span class="line">        <span class="keyword">def</span> currentVal = ctx.currentVal;</span><br><span class="line">        <span class="keyword">def</span> exprStr = ctx.systemParams.get(EXPR_PARAM);</span><br><span class="line">        <span class="keyword">def</span> expr = ~exprStr;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FunctionResult(currentVal ==~ expr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExprCheckTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test1() &#123;</span><br><span class="line">        FunctionContext ctx = <span class="keyword">new</span> FunctionContext();</span><br><span class="line">        ctx.currentVal = <span class="string">"hello"</span></span><br><span class="line">        ctx.systemParams = [<span class="string">"expr"</span>:<span class="string">"hello"</span>]</span><br><span class="line"></span><br><span class="line">        ExprCheck check = <span class="keyword">new</span> ExprCheck();</span><br><span class="line">        FunctionResult result = check.invoke(ctx);</span><br><span class="line">        assertTrue(result.valid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test2() &#123;</span><br><span class="line">        FunctionContext ctx = <span class="keyword">new</span> FunctionContext();</span><br><span class="line">        ctx.currentVal = <span class="string">"hello1"</span></span><br><span class="line">        ctx.systemParams = [<span class="string">"expr"</span>:<span class="string">"hellod+"</span>]</span><br><span class="line"></span><br><span class="line">        ExprCheck check = <span class="keyword">new</span> ExprCheck();</span><br><span class="line">        FunctionResult result = check.invoke(ctx);</span><br><span class="line">        assertTrue(!result.valid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test3() &#123;</span><br><span class="line">        FunctionContext ctx = <span class="keyword">new</span> FunctionContext();</span><br><span class="line">        ctx.currentVal = <span class="string">"hello1"</span></span><br><span class="line">        ctx.systemParams = [<span class="string">"expr"</span>:<span class="string">"hello\\d+"</span>]</span><br><span class="line"></span><br><span class="line">        ExprCheck check = <span class="keyword">new</span> ExprCheck();</span><br><span class="line">        FunctionResult result = check.invoke(ctx);</span><br><span class="line">        assertTrue(result.valid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发单据规则计算引擎的时候引入了groovy脚本计算引擎，其中有一个规则函数：正则函数需要使用正则表达式计算，顺便找了一下groovy里的正则表达式：&lt;/p&gt;
&lt;p&gt;groovy中对于正则表达式的书写进行了简化，同时它仍然是引用的java核心的正则表达式引擎，并没有自己实现一套正则引擎，更多的是从语法糖的形式上进行优化，让人使用起来格外的舒服。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找（find）操作符：=~  返回Matcher类型&lt;/li&gt;
&lt;li&gt;匹配（match）操作符：==~  返回boolean类型&lt;/li&gt;
&lt;li&gt;模式(pattern)操作符：~String  返回Pattern类型&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="groovy" scheme="http://www.lpnote.com/tags/groovy/"/>
    
      <category term="正则表达式" scheme="http://www.lpnote.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jackson-ctrl-char-problem-resovle</title>
    <link href="http://www.lpnote.com/2019/01/08/jackson-ctrl-char-problem-resovle/"/>
    <id>http://www.lpnote.com/2019/01/08/jackson-ctrl-char-problem-resovle/</id>
    <published>2019-01-08T08:32:32.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<p>在使用swagger传递json数据的时候，突然报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.codehaus.jackson.JsonParseException: Illegal unquoted character ((CTRL-CHAR, code 10))</span><br></pre></td></tr></table></figure></p><p>意思是说使用了在json内容中使用了控制字符。而这个code 10是说使用了换行字符。</p><p>解决方法:</p><p>方式1. 使用显式转义方式</p><p>使用\n代替控制性转行（不可打印）字符</p><p>方式2. 配置Jackson<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapp = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用swagger传递json数据的时候，突然报错：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/
      
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
      <category term="json" scheme="http://www.lpnote.com/tags/json/"/>
    
      <category term="jackson" scheme="http://www.lpnote.com/tags/jackson/"/>
    
  </entry>
  
  <entry>
    <title>solve-a-disk-warning-illusion-caused-by-rocketmq</title>
    <link href="http://www.lpnote.com/2019/01/04/solve-a-disk-warning-illusion-caused-by-rocketmq/"/>
    <id>http://www.lpnote.com/2019/01/04/solve-a-disk-warning-illusion-caused-by-rocketmq/</id>
    <published>2019-01-04T07:45:30.000Z</published>
    <updated>2019-02-13T08:59:06.536Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间在运维部署rocketmq的过程中，启动时频繁报一个奇怪的错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2018-12-19 22:20:58 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:20:58 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:08 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br><span class="line">2018-12-19 22:21:08 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:21:08 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:15 INFO StoreStatsService - [STORETPS] put_tps 0.0 get_found_tps 0.0 get_miss_tps 1.799730040493926 get_transfered_tps 0.0</span><br><span class="line">2018-12-19 22:21:15 INFO StoreStatsService - [PAGECACHERT] TotalPut 0, PutMessageDistributeTime [&lt;=0ms]:0 [0~10ms]:0 [10~50ms]:0 [50~100ms]:0 [100~200ms]:0 [200~500ms]:0 [500ms~1s]:0 [1~2s]:0 [2~3s]:0 [3~4s]:0 [4~5s]:0 [5~10s]:0 [10s~]:0 </span><br><span class="line">2018-12-19 22:21:18 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br><span class="line">2018-12-19 22:21:18 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:21:18 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:28 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br><span class="line">2018-12-19 22:21:28 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:21:28 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:38 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br><span class="line">2018-12-19 22:21:38 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:21:38 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:48 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br><span class="line">2018-12-19 22:21:48 INFO StoreScheduledThread1 - begin to delete before 336 hours file. timeup: false spacefull: true manualDeleteFileSeveralTimes: 0 cleanAtOnce: false</span><br><span class="line">2018-12-19 22:21:48 WARN StoreScheduledThread1 - disk space will be full soon, but delete file failed.</span><br><span class="line">2018-12-19 22:21:58 INFO StoreScheduledThread1 - physic disk maybe full soon, so reclaim space, -1.0</span><br></pre></td></tr></table></figure><p>而当时查看了磁盘的容量，远远没有达到rocketmq的磁盘容量警告阀值。剩余的磁盘空间还非常多，一开始是怀疑运维人员没有将rocketmq的存储目录挂载到数据盘，但是经过沟通后发现已经挂载了。</p><p>最后没办法只能是通过阅读rocketmq源代码找原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpaceToDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> ratio = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line">            cleanImmediately = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                String storePathPhysic = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathCommitLog();</span><br><span class="line">                <span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br><span class="line">                <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">                    <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                        DefaultMessageStore.log.error(<span class="string">"physic disk maybe full soon "</span> + physicRatio + <span class="string">", so mark disk full"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">                    cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">                    <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">                        DefaultMessageStore.log.info(<span class="string">"physic disk space OK "</span> + physicRatio + <span class="string">", so mark disk ok"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</span><br><span class="line">                    DefaultMessageStore.log.info(<span class="string">"physic disk maybe full soon, so reclaim space, "</span> + physicRatio);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                String storePathLogics = StorePathConfigHelper</span><br><span class="line">                    .getStorePathConsumeQueue(DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathRootDir());</span><br><span class="line">                <span class="keyword">double</span> logicsRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathLogics);</span><br><span class="line">                <span class="keyword">if</span> (logicsRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">                    <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                        DefaultMessageStore.log.error(<span class="string">"logics disk maybe full soon "</span> + logicsRatio + <span class="string">", so mark disk full"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (logicsRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">                    cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">                    <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">                        DefaultMessageStore.log.info(<span class="string">"logics disk space OK "</span> + logicsRatio + <span class="string">", so mark disk ok"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logicsRatio &lt; <span class="number">0</span> || logicsRatio &gt; ratio) &#123;</span><br><span class="line">                    DefaultMessageStore.log.info(<span class="string">"logics disk maybe full soon, so reclaim space, "</span> + logicsRatio);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>关键错误出现在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br></pre></td></tr></table></figure><p>这里出现返回-1的情况，仔细捋了一把这个工具类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDiskPartitionSpaceUsedPercent</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == path || path.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!file.exists())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> totalSpace = file.getTotalSpace();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (totalSpace &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> freeSpace = file.getFreeSpace();</span><br><span class="line">                <span class="keyword">long</span> usedSpace = totalSpace - freeSpace;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> usedSpace / (<span class="keyword">double</span>) totalSpace;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>综合以上的现象发现只能是发生了异常，而在异常这里，rocketmq自己吃掉了异常，并返回了-1。</p><p>这里个人感觉rocketmq团队在这里处理的方式非常不友好，不仅吃掉了异常而且还返回了一个没意义的值！</p><p>而为什么在计算磁盘空间的时候会出现异常呢，目前能想到的一个原因可能是因为安全原因，导致问题出现，而在linux下selinux是产生文件方面安全问题的重要原因。</p><p>解决方案：叫运维关闭selinux后，情况恢复正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一段时间在运维部署rocketmq的过程中，启动时频繁报一个奇怪的错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="rocketmq" scheme="http://www.lpnote.com/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>hexoclient-usage</title>
    <link href="http://www.lpnote.com/2018/12/30/hexoclient-usage/"/>
    <id>http://www.lpnote.com/2018/12/30/hexoclient-usage/</id>
    <published>2018-12-30T04:30:21.000Z</published>
    <updated>2019-02-13T08:59:06.528Z</updated>
    
    <content type="html"><![CDATA[<p>HexoClient使用帮助</p><p>使用方法链接见：<a href="https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/" target="_blank" rel="noopener">HexoClient使用帮助</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HexoClient使用帮助&lt;/p&gt;
&lt;p&gt;使用方法链接见：&lt;a href=&quot;https://www.mspring.org/2018/11/29/HexoClient%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="转载文章" scheme="http://www.lpnote.com/categories/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="hexo" scheme="http://www.lpnote.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>定制springcloud服务注册到consul中的instanceId</title>
    <link href="http://www.lpnote.com/2018/12/23/customize-instance-id-with-consul-service-registry/"/>
    <id>http://www.lpnote.com/2018/12/23/customize-instance-id-with-consul-service-registry/</id>
    <published>2018-12-23T05:30:09.000Z</published>
    <updated>2019-02-13T08:59:06.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在使用SpringCloud构建微服务过程中，我们使用Consul作为服务的注册中心，中间过程也踩了不少的坑，今天又踩了一个：我们根据官方的建议，在注册springcloud服务的时候，instanceId使用的是以下的配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        health-check-path:</span> <span class="string">/management/health</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">mq-gateway</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">        prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        instance-id:</span> <span class="string">$&#123;spring.cloud.consul.discovery.service-name&#125;:$&#123;server.port&#125;:$&#123;random.value&#125;</span></span><br></pre></td></tr></table></figure></p><p>重点就在于这个instance-id的配置，它由服务名+服务端口+随机值组成。这种看起来唯一且没有什么问题的配置，却是接下来坑的开始。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在微服务的开发过程中，不断有开发人员抱怨在开发过程中一些不正常的停止微服务会导致consul上的服务注册实例越来越多，而且IP和端口都一模一样，究其原因是因为不正常的停止导致consul无法正常反注册服务，导致服务注册驻留在consul上，并变为critical状态，而当程序重启时，重新注册的instance-id又会随着${random.value}的配置而与之前的配置不同，这就导致了不断有不同instance-id的实例注册到consul上，而且他们的健康检测url都一样，这个时候当新服务启动后，所有的原有的critical状态的服务的健康检测都能通过，这时候看到的现象就是consul上这个服务挂了很多个实例（其实这些实例都是同一个服务实例）。</p><p>而且出于安全的原因，有个非常蛋疼的地方在于consul的服务实例反注册还只能由服务注册所在的机器发起才能反注册。</p><p>关于实例重复被注册，在SpringCloud的Github上也有讨论，<a href="https://github.com/spring-cloud/spring-cloud-consul/issues/318" target="_blank" rel="noopener">链接在这里</a>。不过从维护者的回答看出来，好像官方并没有打算做这方面的改进措施。</p><p>求人不如求己，自己也试着来看看有没有解决方案吧。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="一、通过注册修改微服务健康检测的url来规避"><a href="#一、通过注册修改微服务健康检测的url来规避" class="headerlink" title="一、通过注册修改微服务健康检测的url来规避"></a>一、通过注册修改微服务健康检测的url来规避</h2><p>因为多个实例中健康检测的url相同，所以没法区分哪个是正常的实例，所以我们只需要将健康检测的url变成不相同即可，简单的实现如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        health-check-path:</span> <span class="string">/$&#123;spring.cloud.consul.discovery.instance-id&#125;/management/health</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">mq-gateway</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">        prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        instance-id:</span> <span class="string">$&#123;spring.cloud.consul.discovery.service-name&#125;:$&#123;server.port&#125;:$&#123;random.value&#125;</span></span><br></pre></td></tr></table></figure><p>但是这种方案有一个很大的弊端在于：健康检测的url对于每个服务来说变得不可得，都是一些随机的url，会导致外部的一些监控程序无法通过某种规则构造服务的健康检测url，从而掌握服务的健康状况，这是一种对于监控系统来说非常不友好的方式。</p><h2 id="二、通过IP和端口确定instance-id的唯一性"><a href="#二、通过IP和端口确定instance-id的唯一性" class="headerlink" title="二、通过IP和端口确定instance-id的唯一性"></a>二、通过IP和端口确定instance-id的唯一性</h2><p>同一个程序，多次启动导致instance-id不相同的原因在于${random.value}，我们尝试去掉它，而${spring.cloud.consul.discovery.service-name}:${server.port}并不能保证唯一性，我们需要加上一个特征使它变得唯一，很好想到的就是用IP来限制：服务名+IP+PORT，这样基本就限制住了唯一性。</p><p>但是有一个问题是SpringBoot或者SpringCloud并没有提供一个获取本地IP的配置项。这里我们需要仿造${random.value}的配置原理，构造一个我们自己的IP配置获取方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomValuePropertySource</span> <span class="keyword">extends</span> <span class="title">PropertySource</span>&lt;<span class="title">Random</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the random &#123;<span class="doctag">@link</span> PropertySource&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RANDOM_PROPERTY_SOURCE_NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"random."</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RandomValuePropertySource.class);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomValuePropertySource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name, <span class="keyword">new</span> Random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomValuePropertySource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(RANDOM_PROPERTY_SOURCE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!name.startsWith(PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Generating random property for '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getRandomValue(name.substring(PREFIX.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRandomValue</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"int"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getSource().nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"long"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getSource().nextLong();</span><br><span class="line">&#125;</span><br><span class="line">String range = getRange(type, <span class="string">"int"</span>);</span><br><span class="line"><span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getNextIntInRange(range);</span><br><span class="line">&#125;</span><br><span class="line">range = getRange(type, <span class="string">"long"</span>);</span><br><span class="line"><span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getNextLongInRange(range);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"uuid"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getRandomBytes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getRange</span><span class="params">(String type, String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type.startsWith(prefix)) &#123;</span><br><span class="line"><span class="keyword">int</span> startIndex = prefix.length() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (type.length() &gt; startIndex) &#123;</span><br><span class="line"><span class="keyword">return</span> type.substring(startIndex, type.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextIntInRange</span><span class="params">(String range)</span> </span>&#123;</span><br><span class="line">String[] tokens = StringUtils.commaDelimitedListToStringArray(range);</span><br><span class="line"><span class="keyword">int</span> start = Integer.parseInt(tokens[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (tokens.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getSource().nextInt(start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start + getSource().nextInt(Integer.parseInt(tokens[<span class="number">1</span>]) - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextLongInRange</span><span class="params">(String range)</span> </span>&#123;</span><br><span class="line">String[] tokens = StringUtils.commaDelimitedListToStringArray(range);</span><br><span class="line"><span class="keyword">if</span> (tokens.length == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> Math.abs(getSource().nextLong() % Long.parseLong(tokens[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> lowerBound = Long.parseLong(tokens[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">long</span> upperBound = Long.parseLong(tokens[<span class="number">1</span>]) - lowerBound;</span><br><span class="line"><span class="keyword">return</span> lowerBound + Math.abs(getSource().nextLong() % upperBound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRandomBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">getSource().nextBytes(bytes);</span><br><span class="line"><span class="keyword">return</span> DigestUtils.md5DigestAsHex(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">environment.getPropertySources().addAfter(</span><br><span class="line">StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,</span><br><span class="line"><span class="keyword">new</span> RandomValuePropertySource(RANDOM_PROPERTY_SOURCE_NAME));</span><br><span class="line">logger.trace(<span class="string">"RandomValuePropertySource add to Environment"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个给了我们很大的提示，我们自己也可以在SpringBoot程序启动的时候注入一个我们自己的ProperySource将机器的IP作为配置项作为其它其它配置项的引用。并结合我们自己的配置中心客户端，可以在开发人员不感知的情况下就把这个事情给做掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class CustomizeApplication extends SpringApplication &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static ConfigurableApplicationContext run(Object source, String... args) &#123;</span><br><span class="line">        return run(new Object[] &#123; source &#125;, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        advanceFetchApolloConfig(sources);</span><br><span class="line"></span><br><span class="line">        return new CustomizeApplication(sources).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...//此处省略</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">        super.configurePropertySources(environment, args);</span><br><span class="line"></span><br><span class="line">        //add local overwrite config file</span><br><span class="line">        if(localOverwriteConfig != null)&#123;</span><br><span class="line">            environment.getPropertySources().addFirst(localOverwriteConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        environment.getPropertySources().addAfter(ConfigConsts.PREDECESSOR_OF_APOLLO, bootstrapConfig);</span><br><span class="line"></span><br><span class="line">        //注入Server相关属性及配置</span><br><span class="line">        environment.getPropertySources().addAfter(bootstrapConfig.getName(), new ServerPropertiesSource(environment));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...//此处省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的PropertySource:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerPropertiesSource</span> <span class="keyword">extends</span> <span class="title">PropertySource</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(ServerPropertiesSource.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_PROPERTIES_NAME = <span class="string">"xxx.server"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR_PATTERN = SERVER_PROPERTIES_NAME + <span class="string">".addr.pattern"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, Object&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterAccess(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">            .maximumSize(<span class="number">1000</span>).build(<span class="keyword">new</span> CacheLoader&lt;String, Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> _getProperty(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerPropertiesSource</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(SERVER_PROPERTIES_NAME, environment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerPropertiesSource</span><span class="params">(String name, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadingCache.get(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">_getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.startsWithIgnoreCase(name, SERVER_PROPERTIES_NAME)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"get server property for '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getServerProperty(name.substring(SERVER_ADDR_PATTERN.length()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getServerProperty</span><span class="params">(String subName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.startsWithIgnoreCase(subName, <span class="string">".addr"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getServerIp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getServerIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String serverAddrPattern = <span class="keyword">this</span>.environment.getProperty(SERVER_ADDR_PATTERN);</span><br><span class="line">            <span class="keyword">if</span> (serverAddrPattern != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Pattern pattern = Pattern.compile(serverAddrPattern);</span><br><span class="line">                <span class="keyword">return</span> InetAddressUtils.getLocalAddress(pattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> InetAddressUtils.getLocalAddress();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">应用配置：</span><br><span class="line">```yaml</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: <span class="number">127.0</span>.0.1</span><br><span class="line">      port: <span class="number">8500</span></span><br><span class="line">      discovery:</span><br><span class="line">        health-check-path: /management/$&#123;instance-id&#125;/health</span><br><span class="line">        service-name: mq-gateway</span><br><span class="line">        health-check-interval: <span class="number">10</span>s</span><br><span class="line">        prefer-ip-address: <span class="keyword">true</span></span><br><span class="line">        instance-id: $&#123;spring.cloud.consul.discovery.service-name&#125;:$&#123;xxx.server.addr&#125;:$&#123;server.port&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot启动：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableApolloConfig(&#123; &quot;application&quot;, &quot;common.consul&quot;&#125;)</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">CustomizeApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册到Consul中的服务：<br><img src="/2018/12/23/customize-instance-id-with-consul-service-registry/consul.png"></p><p>至此，大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在使用SpringCloud构建微服务过程中，我们使用Consul作为服务的注册中心，中间过程也踩了不少的坑，今天又踩了一个：我们根据官方的建议，在注册springcloud服务的时候，instanceId使用的是以下的配置：&lt;br&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;spring:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  cloud:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    consul:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      host:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      port:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8500&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;      discovery:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        health-check-path:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;/management/health&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        service-name:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;mq-gateway&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        health-check-interval:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        prefer-ip-address:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;        instance-id:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;$&amp;#123;spring.cloud.consul.discovery.service-name&amp;#125;:$&amp;#123;server.port&amp;#125;:$&amp;#123;random.value&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;重点就在于这个instance-id的配置，它由服务名+服务端口+随机值组成。这种看起来唯一且没有什么问题的配置，却是接下来坑的开始。&lt;/p&gt;
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="SpringCloud" scheme="http://www.lpnote.com/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://www.lpnote.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java DNS缓存</title>
    <link href="http://www.lpnote.com/2018/11/23/java-dns-cache/"/>
    <id>http://www.lpnote.com/2018/11/23/java-dns-cache/</id>
    <published>2018-11-23T15:30:21.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdk1-5和1-5之前版本"><a href="#jdk1-5和1-5之前版本" class="headerlink" title="jdk1.5和1.5之前版本"></a>jdk1.5和1.5之前版本</h1><p>默认DNS缓存时间是永久缓存</p><h1 id="jdk-1-6以后"><a href="#jdk-1-6以后" class="headerlink" title="jdk 1.6以后"></a>jdk 1.6以后</h1><p>与security manager策略有关。</p><p>如果没有启用security manager，默认解析成功的DNS缓存时间为30秒，解析失败的DNS缓存时间为10秒。</p><p>策略配置文件：JAVA_HOME/jre/lib/security/java.policy</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>对于多条A记录DNS，在缓存有效期内，取到的IP永远是缓存中全部A记录的第一条，并没有轮循之类的策略。<br>缓存失效之后重新进行DNS解析，如果每次域名解析返回的A记录顺序会发生变化，缓存中的数据顺序也会发生变化，取到的IP也变化。</p><h1 id="缓存修改方法"><a href="#缓存修改方法" class="headerlink" title="缓存修改方法"></a>缓存修改方法</h1><ol><li>jvm启动参数里面配置-Dsun.net.inetaddr.ttl=value</li><li>修改配置文件$JDK_HOME/lib/security/java.security相应的参数networkaddress.cache.ttl=value</li><li>代码里直接设置：java.security.Security.setProperty(”networkaddress.cache.ttl” , “value”);</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jdk1-5和1-5之前版本&quot;&gt;&lt;a href=&quot;#jdk1-5和1-5之前版本&quot; class=&quot;headerlink&quot; title=&quot;jdk1.5和1.5之前版本&quot;&gt;&lt;/a&gt;jdk1.5和1.5之前版本&lt;/h1&gt;&lt;p&gt;默认DNS缓存时间是永久缓存&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="转载文章" scheme="http://www.lpnote.com/categories/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>delete-git-submodule</title>
    <link href="http://www.lpnote.com/2018/10/23/delete-git-submodule/"/>
    <id>http://www.lpnote.com/2018/10/23/delete-git-submodule/</id>
    <published>2018-10-23T15:09:23.000Z</published>
    <updated>2019-02-13T08:59:06.520Z</updated>
    
    <content type="html"><![CDATA[<p>删除一个submodule</p><ol><li><p>删除 .gitsubmodule中对应submodule的条目</p></li><li><p>删除 .git/config 中对应submodule的条目</p></li><li><p>执行 git rm –cached {submodule_path}。注意，路径不要加后面的“/”。例如：你的submodule保存在 theme/maupassant/ 目录。执行命令为： git rm –cached theme/maupassant </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;删除一个submodule&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除 .gitsubmodule中对应submodule的条目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除 .git/config 中对应submodule的条目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行 git rm 
      
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
      <category term="问题记录" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="git" scheme="http://www.lpnote.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>解决前端JS与后端数据交互长整型精度失真的问题</title>
    <link href="http://www.lpnote.com/2017/12/06/accuracy-problems-between-java-and-javascript/"/>
    <id>http://www.lpnote.com/2017/12/06/accuracy-problems-between-java-and-javascript/</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.516Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中采用了twitter开源的snowflake算法的id生成器，生成的id是一个long型的大数，因数值太大，通过json形式传输到前端后，在js解析时，会丢失精度。</p><a id="more"></a><p>解决办法：</p><p>将长整型的数字转为String类型传输到前端，由前端自己负责类型解析。</p><ul><li>如果使用的是Jackson工具包：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(using= ToStringSerializer.class)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><ul><li>如果使用Fastjson工具包：</li></ul><p>局部配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> SerializeConfig serializeConfig = <span class="keyword">new</span> SerializeConfig();</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    serializeConfig.put(Long.class, <span class="keyword">new</span> ObjectSerializer() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, <span class="keyword">int</span> features)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          SerializeWriter out = serializer.getWriter();</span><br><span class="line">          out.writeString(Objects.toString(object, <span class="keyword">null</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">String <span class="title">getResult</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    json.put(<span class="string">"state"</span>, state.getState());</span><br><span class="line">    json.put(<span class="string">"desc"</span>, state.getDesc());</span><br><span class="line">    json.put(<span class="string">"value"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> JSON.toJSONString(json, serializeConfig, SerializerFeature.DisableCircularReferenceDetect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SerializeConfig.getGlobalInstance().put(Long.class, <span class="keyword">new</span> ObjectSerializer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, <span class="keyword">int</span> features)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                SerializeWriter out = serializer.getWriter();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fieldType == <span class="keyword">long</span>.class || fieldType == Long.class) &#123;</span><br><span class="line">                    out.writeString(Objects.toString(object, <span class="keyword">null</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>另一个方式是自己编写JSONSerializer和JSONDeserializer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongJsonSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Long value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String text = (value == <span class="keyword">null</span> ? <span class="keyword">null</span> : String.valueOf(value));</span><br><span class="line">        <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jsonGenerator.writeString(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongJsonDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LongJsonDeserializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String value = jsonParser.getText();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : Long.parseLong(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize</span>(using = LongJsonSerializer.class)</span><br><span class="line"><span class="meta">@JsonDeserialize</span>(using = LongJsonDeserializer.class)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中采用了twitter开源的snowflake算法的id生成器，生成的id是一个long型的大数，因数值太大，通过json形式传输到前端后，在js解析时，会丢失精度。&lt;/p&gt;
    
    </summary>
    
      <category term="问题记录" scheme="http://www.lpnote.com/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="问题解析" scheme="http://www.lpnote.com/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
      <category term="java" scheme="http://www.lpnote.com/tags/java/"/>
    
      <category term="javascript" scheme="http://www.lpnote.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka,Purgatory以及多级时间轮</title>
    <link href="http://www.lpnote.com/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/"/>
    <id>http://www.lpnote.com/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.516Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/" target="_blank" rel="noopener">Apache Kafka, Purgatory, and Hierarchical Timing Wheels</a></p><p><img src="https://www.confluent.io/wp-content/uploads/2016/08/TimingWheels1.png" alt="Time Wheels"></p><p>Apache Kafka有一个称为“请求Purgatory”的数据结构。 这个数据结构会hold住任何尚未达到标准的成功，但又尚未造成错误的请求。 问题是：我们如何有效地跟踪群集中数以万计的的满足要求的异步请求？</p><p>Kafka实现了几个不能立即回应的延时请求类型。 例子：</p><ul><li><p>只有在所有同步副本已经确认写入之后，acks = all的产生请求才能被认为是完整的，并且如果领导失败，我们可以保证它不会丢失。</p></li><li><p>对于min.bytes = 1的提取请求只有在至少有1个byte的数据能够被消费者消费时才会被回答。 这允许“长时间轮询”，使得消费者不必忙于等待检查新数据到达。</p></li></ul><p>这些请求被认为是完成的：</p><p>（a）他们所要求的标准完成<br>（b）或者发生一些超时</p><p>时刻增长这些异步操作的数量与连接的数量成比例，对于Kafka来说，这往往是成千上万的连接数量。</p><p>请求Purgatory被设计用于如此大规模的请求处理，但是旧的实现有一些缺陷。</p><p>在这个博客中，我想解释一下旧执行的问题以及新实现如何解决这个问题。 我也将呈现基准测试结果。</p><a id="more"></a><h1 id="旧的Purgatory的设计"><a href="#旧的Purgatory的设计" class="headerlink" title="旧的Purgatory的设计"></a>旧的Purgatory的设计</h1><p>请求purgatory包括一个超时计时器和事件驱动处理的观察者列表哈希映射。 如果一个请求的条件得不到满足而不能马上满足，就需要把它放入Purgatory中。 当条件满足时，Purgatory中的请求会被完成，或者当超过请求的超时参数指定的时间时被强制完成（超时）。 在旧的设计中，它使用Java DelayQueue来实现定时器。</p><p>当请求完成时，请求不会立即从定时器或观察者列表中删除。 相反，完成的请求会在条件检查期间被删除。 当删除不跟上时，服务器可能会耗尽JVM堆并导致OutOfMemoryError。</p><p>为了缓解这种情况，一个单独的线程（称为收割者线程）在Purgatory中的请求数量（挂起或已完成）超过配置的数量时，清除Purgatory中完成的请求。 清除操作扫描定时器队列和所有观察者列表以找到完成的请求并删除它们。</p><p>通过将此配置参数设置为较低值，服务器可以表面上避免内存问题。 但是，如果服务器太频繁地扫描所有列表，则会付出比较大的性能损失。</p><h1 id="新Purgatory的设计"><a href="#新Purgatory的设计" class="headerlink" title="新Purgatory的设计"></a>新Purgatory的设计</h1><p>新设计的目标是允许立即删除已完成的请求，并显着减少昂贵的清除过程的负担。 它需要交叉引用定时器和请求中的条目。 此外，强烈希望具有O(1)插入/删除成本，因为每个请求/完成都会发生插入/删除操作。</p><p>为了满足这些要求，我们设计了一个基于分级时间轮的新的Purgatory实现[1]。</p><h2 id="分级时间轮"><a href="#分级时间轮" class="headerlink" title="分级时间轮"></a>分级时间轮</h2><p>大小为n的定时轮具有n个时段，并且可以在n <em> u个时间间隔内保持定时器任务。每个桶包含落在相应时间范围内的定时器任务。首先，第一个桶保存[0，u]的任务，第二个桶保存[u </em>（n-1），u <em> n）中的[u，2u），…，第n个桶的任务。每一个时间间隔单位u，计时器滴答并移动到下一个桶，然后终止所有计时器任务。所以，定时器从不在当前时间插入任务，因为它已经过期了。计时器立即运行过期的任务。因此，如果当前时间段为时间t，则在空闲时间之后，空的时间段将成为[t + u </em> n，t +（n + 1）* u）的时间段。定时轮具有O（1）插入/删除（启动定时器/停止定时器）的开销，而基于优先级队列的定时器（例如java.util.concurrent.DelayQueue和java.util.Timer）具有O（log n）插入/删除成本。请注意，DelayQueue或Timer都不支持随机删除。</p><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/TimingWheels1.png"><p>一个简单的时间轮的一个主要缺点是它假定一个定时器请求在距当前时间n <em> u的时间间隔内。如果一个定时器请求超出这个时间间隔，这是一个溢出。分层的时间轮处理这种溢出。这是一个分层组织的时间轮代表溢出到上层轮子。最底层有最好的时间分辨率。时间分辨率越来越粗糙，如果某一级的轮子的分辨率为u，大小为n，则分辨率应该是第二级的n </em> u，第三级的n2 * u，依此类推。在每个级别，溢出都被委托给高一级的车轮。当较高级别的轮子时间到达时，它将计时器任务重新插入较低级别。高一级的时间轮可以按需创建。当溢出存储桶中的存储桶到期时，其中的所有任务将被递归地重新插入定时器。然后任务被移动到更精细的轮子或被执行。插入（启动定时器）的开销是O（m），其中m是车轮的数量，通常与系统中的请求数量相比非常小，并且删除（停止计时）的开销仍然是O（1 ）。</p><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/TimingWheels2.png"><h2 id="双向链轮列表中的时间轮桶"><a href="#双向链轮列表中的时间轮桶" class="headerlink" title="双向链轮列表中的时间轮桶"></a>双向链轮列表中的时间轮桶</h2><p>在新的设计中，我们使用自己的双向链表来实现时序轮中的桶。 双向链表的优点是它允许O（1）插入/删除一个列表项，如果我们有访问链表单元的话。</p><p>计时器任务实例在排队到计时器队列时将链接单元保存在自身中。 任务完成或取消时，使用保存在任务本身中的链接单元更新列表。</p><h2 id="使用DelayQueue驱动时钟"><a href="#使用DelayQueue驱动时钟" class="headerlink" title="使用DelayQueue驱动时钟"></a>使用DelayQueue驱动时钟</h2><p>一个简单的实现可以使用一个线程，唤醒每个单位时间，并做滴答，检查是否有任何任务在桶中。 Purgatory的单位时间是1ms（u = 1ms）。 如果最低级别的请求稀疏，这可能是浪费的。 通常情况下是这样的，因为大多数请求在插入最低级别的车轮之前是满足的。 如果一个线程只有在非空的存储桶过期才会唤醒，那将会很好。 新的Purgatory通过使用java.util.concurrent.DelayQueue类似于旧的实现，但是我们排队任务桶而不是单独的任务。 这种设计具有性能优势。 DelayQueue中的项目数量以桶的数量为上限，通常远小于任务数量，因此DelayQueue内的优先级队列的offer/poll操作的数量将显着减少。</p><h2 id="清除watch列表"><a href="#清除watch列表" class="headerlink" title="清除watch列表"></a>清除watch列表</h2><p>在旧的实现中，观察者列表的清除操作由总大小触发。问题是，即使没有太多请求清除，观察者列表也可能会超出阈值。发生这种情况时，会增加很多CPU负载。理想情况下，清除操作应该由观察者列出的已完成请求的数量触发。</p><p>在新设计中，已经完成的请求立即以O（1）成本从定时器队列中移除。这意味着任何时候定时器队列中的请求数量是待处理请求数量。因此，如果我们知道Purgatory中不同请求的总数，包括未决请求数量和已完成但仍然监视的数量的总和，我们可以避免不必要的清除操作。跟踪Purgatory中不同请求的确切数量是不太现实的，因为一个请求可能被监视，也可能不被监视，状态可能只在一瞬间变换。在新设计中，我们只粗略预估Purgatory中的请求总数，而不是试图维持正确的数量统计。</p><p>估计的请求数量按以下保持：</p><ul><li>估计的请求总数E会随着新的请求被监视而增加。</li><li>在开始清除操作之前，我们将估计的总请求数重置为定时器队列的大小。这是当前的待处理请求的数量。如果在清除期间没有任何请求被添加到Purgatory，则E是清除后正确的请求数量。</li><li>如果清除过程中某些请求被添加到Purgatory，则E增加到E+新观察请求的数量。这可能被高估，因为有可能在清除操作期间完成一些新的请求并从观察者列表中删除。我们预计高估和高估的可能性很小。</li></ul><h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h1><p>我们比较了两个Purgatory实施的入队表现，旧的实施和新的实施。这是一个微观基准。它只是衡量Purgatory入队的表现。Purgatory与系统的其他部分分离，并使用一个没有用处的测试要求。因此，真实系统中Purgatory的吞吐量可能会低于测试所显示的数量。</p><p>在测试中，请求的间隔假定遵循指数分布。每个请求都需要从对数正态分布中抽取一段时间。通过调整对数正态分布的形状，我们可以测试不同的超时率。</p><p>刻度大小为1ms，轮子大小为20.超时设置为200ms。请求的数据大小是100字节。对于较低的超时率情况，我们选择75%均线 = 60ms和50%均线 = 20。对于高超时率情况，我们选择75%均线 = 400ms和50%均线 = 200ms。总共有100万个请求在每次运行中排队。</p><p>请求由一个单独的线程主动完成。应该在超时之前完成的请求被排队到另一个DelayQueue。而一个单独的线程保持轮询并完成它们。实际完成时间无法保证准确性。</p><p>JVM堆大小设置为200M来重现内存紧张的情况。</p><p>结果表明，高排队率区域有显着差异。随着目标机率的提高，两种实施方式都能满足要求。然而，在低超时的情况下，旧的实现极限大约40000 RPS（请求每秒），而新的实现并没有显示任何显着的性能下降，在高超时的情况下，旧的实现极限大约25000 RPS，而新的实现在这个基准测试中达到了105000 RPS。</p><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/enq_rate.png"><p>另外，在新的实现中CPU的使用情况要好得多。 请注意，由于可伸缩性的限制，旧的实现没有高于〜40000 RPS的数据点。 同时也注意到它的CPU时间在1.2左右饱和，而在新的实现中稳步上升。 这表明旧的实现可能由于同步而遇到并发问题。</p><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/cms_time.png"><p>最后，我们测量了ParNew收集和CMS收集的总GC时间（毫秒）。 旧的设计和新的设计在维持的入队率没有太大差别。 再次注意，由于可伸缩性限制，旧的实现没有高于〜40000 RPS的数据点。</p><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/parnew_time.png"><img src="/2017/11/15/apache-kafka-purgatory-hierarchical-timing-wheels/cms_time.png"><h1 id="概要总结"><a href="#概要总结" class="headerlink" title="概要总结"></a>概要总结</h1><p>在新设计中，我们使用多级时间轮作为定时器桶的超时定时器和DelayQueue按需提前时钟。 O（1）成本立即从计时器队列中删除已完成的请求。 桶仍然在延迟队列中，但桶的数量是有限的。 而且，在一个健康的系统中，大多数请求应该在超时之前完成，并且在离开延迟队列之前许多桶变空了。 因此，计时器应该很少有较低间隔的桶。 这种设计的优点是，定时器队列中的请求数量是任何时候的待处理请求数量。 这使我们能够估计需要清除的请求数量。 我们可以避免观察者列表的不必要的清除操作。 因此，我们在请求速率方面实现了更高的可扩展性，CPU使用率更高。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>[1] <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/ton97-timing-wheels.pdf" target="_blank" rel="noopener">George Varghese , Anthony Lauck, Hashed and hierarchical timing wheels: efficient data structures for implementing a timer facility, IEEE/ACM Transactions on Networking (TON), v.5 n.6, p.824-834, Dec. 1997</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Kafka, Purgatory, and Hierarchical Timing Wheels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.confluent.io/wp-content/uploads/2016/08/TimingWheels1.png&quot; alt=&quot;Time Wheels&quot;&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka有一个称为“请求Purgatory”的数据结构。 这个数据结构会hold住任何尚未达到标准的成功，但又尚未造成错误的请求。 问题是：我们如何有效地跟踪群集中数以万计的的满足要求的异步请求？&lt;/p&gt;
&lt;p&gt;Kafka实现了几个不能立即回应的延时请求类型。 例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有在所有同步副本已经确认写入之后，acks = all的产生请求才能被认为是完整的，并且如果领导失败，我们可以保证它不会丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于min.bytes = 1的提取请求只有在至少有1个byte的数据能够被消费者消费时才会被回答。 这允许“长时间轮询”，使得消费者不必忙于等待检查新数据到达。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些请求被认为是完成的：&lt;/p&gt;
&lt;p&gt;（a）他们所要求的标准完成&lt;br&gt;（b）或者发生一些超时&lt;/p&gt;
&lt;p&gt;时刻增长这些异步操作的数量与连接的数量成比例，对于Kafka来说，这往往是成千上万的连接数量。&lt;/p&gt;
&lt;p&gt;请求Purgatory被设计用于如此大规模的请求处理，但是旧的实现有一些缺陷。&lt;/p&gt;
&lt;p&gt;在这个博客中，我想解释一下旧执行的问题以及新实现如何解决这个问题。 我也将呈现基准测试结果。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://www.lpnote.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="kafka" scheme="http://www.lpnote.com/tags/kafka/"/>
    
      <category term="timewheels" scheme="http://www.lpnote.com/tags/timewheels/"/>
    
      <category term="timer" scheme="http://www.lpnote.com/tags/timer/"/>
    
  </entry>
  
  <entry>
    <title>基于Hash和多级时间轮：实现定时器的高效数据结构</title>
    <link href="http://www.lpnote.com/2017/11/15/hashed-and-hierarchical-timing-wheels/"/>
    <id>http://www.lpnote.com/2017/11/15/hashed-and-hierarchical-timing-wheels/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.528Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://blog.acolyer.org/2015/11/23/hashed-and-hierarchical-timing-wheels/" target="_blank" rel="noopener">Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility</a></p><p>Yashiro Matsuda最近写了一篇博文<a href="http://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels" target="_blank" rel="noopener">Apache Kafka’s use of Hierarchical Timing Wheels</a> 用于监控大量的延时操作。 在Kafka用例中，每个请求都处于“Purgatory”数据结构中，并且与事件驱动处理的超时计时器和观察者列表图相关联。 有效跟踪到期定时器是一个常见问题。 这个原则可以适用于任何跟踪未完成的请求或延时消息系统。</p><p>今天的选择是Varghese和Lauck在1987年发表的一篇论文，他们在这篇论文中研究了一些有效管理定时器的方法，并介绍了Kafka所使用的分层定时轮的概念。 他们将定时器建模为两个面向用户的操作，即启动和停止，以及两个内部操作：每个滴答步进和过期处理。</p><ul><li><p>启动计时器由客户端调用，指定一个计时器持续时间和一个回调。在作者的模型中，客户端还传入一个请求ID来区分计时器，但是现在我们更倾向于返回一个计时器ID来响应启动计时器的请求。</p></li><li><p>停止定时器接收一个请求（定时器）ID，并找到并停止（删除）相关的定时器。</p></li><li><p>在计时器时钟的每个“滴答声”上都会发生清算。如果设置定时器的粒度单位是T个单位时间（例如1秒），则每T个单位时间将发生一个清算。它检查是否有任何未完成的定时器已经过期，如果是则删除它们并调用过期处理。</p></li><li><p>到期处理负责调用用户提供的回调（或其他用户请求的操作，具体取决于您的模型）。</p></li></ul><p>不同的数据结构和算法在执行这些操作的成本方面有不同的复杂性（例如，启动一个定时器是一个恒定的时间操作，取决于现有定时器的数量，或者甚至是一些其他变量？）。 我们有七种不同的计时器管理方案，指导方针是“对于一个普通的定时器模块，这个模块预计在各种环境下都能正常工作，我们推荐方案6或7”。方案6是“散列定时轮”和方案7是“分层定时轮”。</p><a id="more"></a><p>让我们来看看这些方案：</p><h1 id="1-无序列表的定时器"><a href="#1-无序列表的定时器" class="headerlink" title="1.无序列表的定时器"></a>1.无序列表的定时器</h1><p>保留一个无序的列表定时器，并跟踪每个定时器的剩余时间。开始时，只需将新的计时器添加到列表中。每个“嘀嗒”周期必须遍历完整列表，并在每笔记帐中减少每个计时器的剩余时间。如果一个定时器到达零，它将从列表中删除，并调用过期处理。<br>因此启动一个定时器是O（1），停止一个定时器是O（1），并且每个滴答处理是O（n），其中n是未完成定时器的数量。</p><h1 id="2-有序列表计时器"><a href="#2-有序列表计时器" class="headerlink" title="2.有序列表计时器"></a>2.有序列表计时器</h1><p>保留方案1中的列表定时器，但记录绝对到期时间（不是剩余时间），并保持定时器列表的排序时间（定时器最接近于列表头部的到期时间）。在每个时钟周期比较列表头部的定时器的到期时间和当前的时钟，并且如果定时器的到期时间是小于当前时间，则删除到期定时器;  继续这样做这样的比较，直到列表的头部包含一个过期时间大于当前时间的计时器。由于在列表中搜索正确的位置来插入它，所以现在启动一个计时器为O（n），但是每个嘀嗒处理是O（1）。</p><h1 id="3-定时器树"><a href="#3-定时器树" class="headerlink" title="3.定时器树"></a>3.定时器树</h1><p>对于比较大的n，我们可以通过在基于tree的数据结构中保留定时器来改进方案2。 这意味着我们可以在O(log(n))内为有序列表插入（启动）定时器。</p><h1 id="4-简单的时间轮"><a href="#4-简单的时间轮" class="headerlink" title="4.简单的时间轮"></a>4.简单的时间轮</h1><p>当所有定时器的最大周期不超过MaxInterval时，简单的定时轮的方法是适用的，我们可以用MaxInterval槽（每个代表一个滴答）构造一个循环缓冲区。当前时间由缓冲区中的索引表示。插入一个计时器，过期时间j(小于MaxInterval）; 在未来的MaxInterval时间单位中，我们移动环上的j个时隙，并将定时器添加到该时隙中的定时器列表中。 每次“嘀嗒”（模拟时钟，非常形象的描述了时间轮的走动），当前时间索引移动环中的一个槽，并在新槽中的所有定时器上执行到期处理。</p><p>开始，停止和每个“嘀嗒”操作都是O(1)。</p><h1 id="5-带有序定时器列表的散列轮"><a href="#5-带有序定时器列表的散列轮" class="headerlink" title="5.带有序定时器列表的散列轮"></a>5.带有序定时器列表的散列轮</h1><p>如果MaxInterval比较大（例如32位定时器），简单的定时轮就可能会使用大量的内存。 我们可以使用散列的形式而不是每时间单位使用一个插槽。 构建一个具有固定数量的槽的循环缓冲区(2的指数会比较有效率)，并且当前时间索引像以前一样在环上前进一个位置。 要插入将来会过期j个时间单位的计时器，计算一个增量时隙 s = j％num-buckets。 将定时器插入环中，并等待其到期。 由于在任何给定的时隙中可能有多个定时器，因此我们为每个时隙维护一个有序的定时器列表。每次处理时移动当前时间索引并处理在方案2中找到的定时器列表。插入定时器的最坏情况延迟是O（n），但是平均值是O（1）。 每次处理“嘀嗒”是O（1）。</p><h1 id="6-无序定时器列表的哈希轮"><a href="#6-无序定时器列表的哈希轮" class="headerlink" title="6.无序定时器列表的哈希轮"></a>6.无序定时器列表的哈希轮</h1><p>这是方案5中的一个变体，其中不是存储绝对的到期时间，而是存储每个计时器将来在遍历环的次数。 为了插入一个计时器，将来会计算一个时间单位，计算一个计数器值c = j / num-buckets和一个时隙delta s = j％num-bucket。 用计数器值c将定时器的槽插入环中。保持定时器在每个槽中的无序列表中。</p><p>现在启动一个计时器是O（1），而每个滴答簿记是最坏的情况O（n），但是O（1）是平均的。</p><h1 id="7-分级时间轮"><a href="#7-分级时间轮" class="headerlink" title="7.分级时间轮"></a>7.分级时间轮</h1><p>处理由简单的定时轮方法引起的存储器问题的另一种方式是在层次结构中使用多个定时轮。假设我们要存储第二个粒度的定时器，将来可以设置长达100天。我们可以建造四个轮子：</p><ul><li>一个“天”轮有100个插槽</li><li>一个“小时”轮有24插槽</li><li>一个“分钟”轮有60个插槽</li><li>一个“秒钟”轮有60个插槽</li></ul><p>这总共有244个插槽，总计864万个可能的计时器值。每当我们在一个轮子上完成一次完整的转动，我们就把下一个较大的轮子向前推进一个槽位（本文用分钟，小时和星期计时钟来描述一个微小的变化，但效果是一样的）。例如，当秒轮转回到索引“0”时，我们将分针轮中的索引指针移动一个位置。然后，我们把时间轮上的所有定时器（将在接下来的60秒内到期），并将它们插入到秒针轮中正确的位置。秒轮中的过期时间处理完全按照方案4中所述的方式工作（这只是一个简单的计时轮，恰好在每次旋转时得到补充）。</p><p>要插入一个计时器，找到计时器应该到期的一个或多个车轮单元的第一个车轮（从最大单位到最小）。例如，一个计时器将会在未来11小时15分15秒的时间内插入小时轮的current-index + 11时隙，用计时器存储剩余的15分15秒。在小时轮前进11个位置后，该计时器将从该轮上移除，并在分针轮中的当前索引+ 15个插槽中插入，存储剩余的15秒。当分钟轮随后前进15个位置时，该计时器将从轮中移出，并放置在秒针轮中的“当前索引+15”轮槽中。 15秒后，计时器将过期！</p><p>插入为O（n），而每个滴答簿记是最坏的情况O（n），但是O（1）是平均的。</p><p>注意：本文使用秒，分，小时，天的例子，这当然使得它很容易遵循及更容易理解和记忆，但如果你只是给定时器，例如，在未来的t秒内达到32位计时器值，那么简单地将其分成四个轮子，每个轮子有28个槽或类似的轮子（这使得确定进入哪个轮子是非常有效的）。</p><p>在方案6和7之间选择</p><p>在任何给定的情况下，方案6或7是否更好取决于许多参数：</p><ul><li>n，定时器的数量</li><li>M，可用插槽的总数</li><li>m，级别的数量（用于分级方法）</li><li>T，平均时间间隔</li></ul><p>根据方案6计算一个条目的散列和索引成本在方案7（将计时器条目移动到下一个轮子的成本）之下。</p><p>对于方案6，成本大约是n’s indexcost / M，方案7是nm’s migratecost / T。</p><p>由于costindex和costmigrate不会有很大的不同，对于较小的T值和较大的M值，方案6对于START-TIMER和PER-TICK-BOOKKEEPING都可能比方案7更好。然而，对于大的T值和小的M值，方案7对于PER-TICK-BOOKKEEPING将具有更好的平均成本（等待时间），但对于START-TIMER来说成本更高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://blog.acolyer.org/2015/11/23/hashed-and-hierarchical-timing-wheels/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Yashiro Matsuda最近写了一篇博文&lt;a href=&quot;http://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Kafka’s use of Hierarchical Timing Wheels&lt;/a&gt; 用于监控大量的延时操作。 在Kafka用例中，每个请求都处于“Purgatory”数据结构中，并且与事件驱动处理的超时计时器和观察者列表图相关联。 有效跟踪到期定时器是一个常见问题。 这个原则可以适用于任何跟踪未完成的请求或延时消息系统。&lt;/p&gt;
&lt;p&gt;今天的选择是Varghese和Lauck在1987年发表的一篇论文，他们在这篇论文中研究了一些有效管理定时器的方法，并介绍了Kafka所使用的分层定时轮的概念。 他们将定时器建模为两个面向用户的操作，即启动和停止，以及两个内部操作：每个滴答步进和过期处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动计时器由客户端调用，指定一个计时器持续时间和一个回调。在作者的模型中，客户端还传入一个请求ID来区分计时器，但是现在我们更倾向于返回一个计时器ID来响应启动计时器的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;停止定时器接收一个请求（定时器）ID，并找到并停止（删除）相关的定时器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在计时器时钟的每个“滴答声”上都会发生清算。如果设置定时器的粒度单位是T个单位时间（例如1秒），则每T个单位时间将发生一个清算。它检查是否有任何未完成的定时器已经过期，如果是则删除它们并调用过期处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;到期处理负责调用用户提供的回调（或其他用户请求的操作，具体取决于您的模型）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的数据结构和算法在执行这些操作的成本方面有不同的复杂性（例如，启动一个定时器是一个恒定的时间操作，取决于现有定时器的数量，或者甚至是一些其他变量？）。 我们有七种不同的计时器管理方案，指导方针是“对于一个普通的定时器模块，这个模块预计在各种环境下都能正常工作，我们推荐方案6或7”。方案6是“散列定时轮”和方案7是“分层定时轮”。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://www.lpnote.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="timer" scheme="http://www.lpnote.com/tags/timer/"/>
    
      <category term="timewheel" scheme="http://www.lpnote.com/tags/timewheel/"/>
    
  </entry>
  
  <entry>
    <title>Nginx_Session_Sticky踩坑记录</title>
    <link href="http://www.lpnote.com/2017/09/11/problem-analysis-of-nginx-session-sticky/"/>
    <id>http://www.lpnote.com/2017/09/11/problem-analysis-of-nginx-session-sticky/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见Session方案"><a href="#常见Session方案" class="headerlink" title="常见Session方案"></a>常见Session方案</h1><p>一个多用户的WEB系统一定离不开多用户的登录和会话保持的问题，用户登录可以通过SSO单点登录解决，但是用户的SESSION会话保持是需要一个基础设施来支撑的。对于传统的单机部署的WEB应用，SESSION会话由本机的应用服务器（tomcat/jetty/jboss）负责应用SESSION会话的保持。但是对于分布式部署的WEB应用来说，单机的会话保持显然并不能适用在这种场景下面，下面是分布式WEB应用场景时一般采取的策略：</p><ul><li>方案一：通过前端负载均衡进行SESSION_STICKY</li><li>方案二：应用服务器层SESSION同步</li><li>方案三：应用SESSION层统一管理</li></ul><a id="more"></a><p>1、对于方案一，操作简单，应用不需要进行任何设置，同一用户首次访问应用提供服务的某台服务器后，后续的访问请求会一直发往该台服务器进行处理，这里解决的就是SESSION本机存储的问题，如果采用的是SESSION本地存储，然后请求又是在多台机器之间分发，那么会造成用户不断的登录和退出，无法正常使用应用。这种方案一般在负载均衡服务器(Nginx/Apache等）上进行配置即可。</p><p>2、对于方案二，操作方式稍微比方案一要复杂，但是仍然向使用者屏蔽了使用细节。对于该方案要求后端的真实应用服务器之间要建立同步通道进行SESSION会话数据的同步，这种方案在后端真实服务器相对较少时可以采用没有太多问题，但是一旦服务器数量以及用户数量并发超过一定数量会造成网络风暴的问题。试想，一个用户的SESSION在某台服务器进行修改后要同步到所有其它服务器的SESSION管理存储上，这是一个1+N的过程，性能和网络都会无法承担这样的开销。</p><p>3、对于方案三，这是目前大型互联网公司采用的方案,如淘宝，同样对使用用户屏蔽实现细节，用户使用过程中就好像使用原生的SESSION一样。方案三采用集中式SESSION存放，应用服务器并不负责用户SESSION的管理，SESSION管理交由统一封装的SESSION框架层负责处理，SESSION框架层拦截应用服务器的SESSION存取并与SESSION存储交互获取和设置数据，这里的SESESSION的存储又分为多种方式，常见的有：缓存服务，Cookie等。一些不重要的，非关键性的用户数据可以通过SESSION框架存入Cookie中，而重要的用户数据存入远程的缓存服务中。</p><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>我们这里有一个应用，线上会部署多台服务器，当时为了方便快速上线就采用了上面方案一的方式，在线上Nginx上配置了session_sticky，然而这正是问题的始源：</p><p>通过我们自己的APM监控系统发现在最初后端的两台服务器正常的各自分担了50%的网络流量，但是在后面的一段时间里流量会慢慢的向基中一台机器聚集，而另一台机器流量几乎降低到微乎其微。这个问题困扰了好几天，前面几天一直发现了该问题，但是一直忙于处理其它事务，今天终于有时间慢慢来分析这方面的问题。</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、首先查看的Nginx的配置是否正确</p><img src="/2017/09/11/problem-analysis-of-nginx-session-sticky/FD684B9B-728E-45AA-9566-598BE2487350.png"><p>采用了SESSION_STICKY，并且两台服务器间采用一样的权重比率。没问题。</p><p>2、排查用户访问IP的问题</p><p>最开始一直认为Nginx的SESSION_STICKY是通过用户的IP进行的分流（其实后面证明我的想法是错的），所以想到的是查找用户访问的IP，通过询问运维，得到的结论是用户都是通过内网统一一个IP访问，这里有一个误导，导致我认为这就是导致该问题的原因。如果真是按IP对用户进行分流切分的话，那如何解释之前可以平均分配流量的问题呢？我一直在不停的反问我自己。</p><p>3、在多个不同用户的机器上重现问题</p><p>我使用了多个同事的电脑进行操作以及查看资料，发现Nginx的SESSION_STICKY是通过Nginx反写cookie实现的，通过查看多个同事的浏览器cookie，我发现了这个cookie：route=739d4e2d09f01c606bc43936e6e743e3; 基本上是所有的同事浏览器cookie都是一样的，这也应验了为什么基本上的流量都会往一台机器上发送了。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>既然有了上面的问题排查，那么最重要的一个问题就落在了为什么不同的用户会产生同样的cookie呢，我试着将我自己的电脑上的cookie清空，然后再重新登录，再查看该cookie值。重复这样几次后，我发现均衡正常了，可以按一定的比率会话分别粘滞在两台机器上。同时我也仔细翻看了Nginx的SESSION_STICKY说明，其中有一条也让我恍然大悟：Nginx SESSION_STICKY产生的cookie是根据配置按后端可用的upstream服务器中的一台的IP通过MD5加密（或明文，可配置）后得到的一串数字，而并非是由前端的IP决定。</p><p>NGINX SESSION_STICKY 原理：</p><img src="/2017/09/11/problem-analysis-of-nginx-session-sticky/sticky0.jpg"><img src="/2017/09/11/problem-analysis-of-nginx-session-sticky/sticky1.png"><p>这里导致上面的问题的原因慢慢的开始浮出水面：</p><p>1、为什么Cookie是一直不变的？</p><p>原因是大部分的同事都是使用笔记本，特别是大部分人都是MacPro控，所以对于他们来说，工作或者下班时是重来不需要关闭电脑的，电脑一合就走人，所以浏览器是一直打开的未关闭过，这种情况也在部分使用台式机的同事存在，也是下班电脑睡眠就走人，并未关闭浏览器。对于route这个cookie是浏览器关闭才会失效，所以一直开启的浏览器时该cookie会一直有效。</p><p>2、为什么基本上的同事的Cookie都是一样的？</p><p>这个问题就要从应用的发布说起了。我们的发布流程是灰度发布过程，在应用发布时是一台一台的发布的，总共两台机器，其中第一台的发布的过程中大量的请求被定向到另一台机器，而第一台发布完成时流量并不会切换回来，因为新产生的cookie已经是第二台机器的cookie，并且该cookie是一直有效的，除非有人为的手动关闭整个浏览器。这就解释了为什么应用在第一次上线时是流量均衡的，但是一旦后面上线过后流量变成只向其中一台聚集的情况，这也是使用Nginx Session_Sticky的一个问题。</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>问题解决方案其实已经在上面第一段内容提及了，实现会话保持的三个方案中，选择其中一个，对于我们之前使用的第一种方案，其实有相应的缓解方式，就是增开几台机器，让流量在发布的时候也分布到其它机器，只是在我们的场景下，只有两台机器，当发布进行时，所有的流量都汇聚到其中一台上，以后也固化到这台访问了。如果将机器扩充多一些，那么在一台机器发布时，流量会分担到其它机器，整个集群相对来说还是比较均衡的（其中只有一台没啥流量，相当于是浪费一台机器），能保证整体流量在N-1台机器上均衡（N为应用机器总量）。</p><p>我们解决的方式是使用方案三，使用外置的Session会话存储的方案。这里我们可以自己写一套Session管理的框架，但是介于开源世界已经有实现方案了，比如Spring的session方案。于是我们的方案就是基于此来做改造。我们使用spring session框架，基于redis集群的会话保持方案改造了自己的应用，非常简单快速的实现了session的外置存储支持，以及应用的无状态化。基于此，nginx的session_sticky配置也可以去掉了，应用也可以很好的扩容了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见Session方案&quot;&gt;&lt;a href=&quot;#常见Session方案&quot; class=&quot;headerlink&quot; title=&quot;常见Session方案&quot;&gt;&lt;/a&gt;常见Session方案&lt;/h1&gt;&lt;p&gt;一个多用户的WEB系统一定离不开多用户的登录和会话保持的问题，用户登录可以通过SSO单点登录解决，但是用户的SESSION会话保持是需要一个基础设施来支撑的。对于传统的单机部署的WEB应用，SESSION会话由本机的应用服务器（tomcat/jetty/jboss）负责应用SESSION会话的保持。但是对于分布式部署的WEB应用来说，单机的会话保持显然并不能适用在这种场景下面，下面是分布式WEB应用场景时一般采取的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案一：通过前端负载均衡进行SESSION_STICKY&lt;/li&gt;
&lt;li&gt;方案二：应用服务器层SESSION同步&lt;/li&gt;
&lt;li&gt;方案三：应用SESSION层统一管理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="原创文章" scheme="http://www.lpnote.com/categories/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="nginx" scheme="http://www.lpnote.com/tags/nginx/"/>
    
      <category term="踩坑" scheme="http://www.lpnote.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="session" scheme="http://www.lpnote.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>leetcode算法3_最长无重复子串长度</title>
    <link href="http://www.lpnote.com/2017/09/07/leetcode-3-longest-substring-without-repeating-characters/"/>
    <id>http://www.lpnote.com/2017/09/07/leetcode-3-longest-substring-without-repeating-characters/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个字符串，找到最长子串的长度，而不重复字符。</p></blockquote><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>给定“abcabcbb”，答案是“abc”，长度为3。</p><p>给定“bbbbb”，答案是“b”，长度为1。</p><p>给定“pwwkew”，答案是“wke”，长度为3.请注意，答案必须是子字符串，“pwke”是子序列而不是子字符串。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>利用滑动窗口思想，滑动窗口内的字符将不会重复，滑动窗口利用两个索引i,j分别指向窗口的前后界限，通过分别移动i，j指针来寻求最大子串长度。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="方法＃1-暴力方式-超时"><a href="#方法＃1-暴力方式-超时" class="headerlink" title="方法＃1 暴力方式[超时]"></a>方法＃1 暴力方式[超时]</h2><ul><li>思路</li></ul><p>检查所有子字符串逐个查看是否没有重复的字符。</p><ul><li>算法</li></ul><p>假设我们有一个函数boolean allUnique（String substring），如果子字符串中的字符都是唯一的，否则返回true，否则为false。我们可以遍历给定字符串s的所有可能的子字符串，并调用allUnique函数。如果事实证明是正确的，那么我们更新我们的子字符串的最大长度的答案，而不会有重复的字符。</p><p>现在我们填写缺失的部分：</p><p>要枚举给定字符串的所有子字符串，我们枚举它们的开始和结束索引。假设开始和结束指数分别为i和j。那么我们有0 &lt;= i &lt; j &lt;=n（这里的结束索引j按照惯例排除）。因此，使用从0到n-1的i的两个嵌套循环和从i + 1到n的j，我们可以枚举s的所有子串。</p><p>要检查一个字符串是否有重复的字符，我们可以使用一个字符串。我们遍历字符串中的所有字符，并将它们逐个放入。在放置一个字符之前，我们检查该集合是否已经包含它。如果是这样，我们返回false。循环后，我们返回true。</p><ul><li>Javaw代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lengthOfLongestSubstring（String s）&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length（）;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>（<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i ++）</span><br><span class="line">            <span class="keyword">for</span>（<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++）</span><br><span class="line">                <span class="keyword">if</span>（allUnique（s，i，j））ans = Math.max（ans，j-i）;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allUnique（String s，<span class="keyword">int</span> start，<span class="keyword">int</span> end）&#123;</span><br><span class="line">        set &lt;Character&gt; set = <span class="keyword">new</span> HashSet &lt;&gt;（）;</span><br><span class="line">        <span class="keyword">for</span>（<span class="keyword">int</span> i = start; i &lt;end; i ++）&#123;</span><br><span class="line">            Character ch = s.charAt（i）;</span><br><span class="line">            <span class="keyword">if</span>（set.contains（ch））<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            set.add（ch）;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂性分析</li></ul><p>时间复杂度：O（n ^ 3）</p><p>空间复杂度：O（min（n，m））O（min（n，m））。我们需要O（k）空格用于检查子串没有重复字符，其中k是Set的大小。集合的大小由字符串n的大小和字符集/字母表m的大小限定。</p><h2 id="方法＃2滑动窗口-已接受"><a href="#方法＃2滑动窗口-已接受" class="headerlink" title="方法＃2滑动窗口[已接受]"></a>方法＃2滑动窗口[已接受]</h2><ul><li>算法</li></ul><p>上面算法一方法非常简单。但是太慢了那么我们如何才能优化呢？</p><p>在上面的方法中，我们反复检查一个子字符串，看看它是否具有重复的字符。但这是没有必要的。如果一个子字符串s[i,j）是从索引i到j-1已经被检查为没有重复的字符。我们只需要检查s[j]是否已经在子串s[i,j)中。要检查字符是否已经在子字符串中，我们可以扫描子字符串，导致O（n ^ 2）算法。但我们可以做得更好。</p><p>通过使用HashSet作为滑动窗口，检查当前的字符是否可以在O（1）中完成。</p><p>滑动窗口是数组/字符串问题中常用的抽象概念。窗口是数组/字符串中通常由开始和结束索引定义的元素范围，即[i，j)（左闭合，右开）。滑动窗口是一个窗口，将其两个边界滑动到某个方向。例如，如果我们通过一个元素将[i，j）向右滑动，则它变为[i + 1，j + 1）（左闭右开）。</p><p>回到我们的问题。我们使用HashSet将字符存储在当前窗口[i，j）（j = i）。然后我们将索引j向右滑动。如果不在HashSet中，我们会进一步滑动j。这样做直到s[j]已经在HashSet中。在这一点上，我们发现没有重复字符的子字符串的最大大小从索引i开始。重复上面的步骤，我们就能得到我们的答案。</p><ul><li><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂性分析</p></li></ul><p>时间复杂度： O(2n) = O(n)。最糟糕的情况是每个字符都需要被i,j指针访问两次。<br>空间复杂度： O(min(m,n))。 和上面的方案一样，我们同样需要一个O(k)的空间用于滑动窗口，k表示滑动窗口大小。这个大小取决于字符串n的大小以及字符集的大小m</p><h2 id="方法＃3滑动窗优化-已接受"><a href="#方法＃3滑动窗优化-已接受" class="headerlink" title="方法＃3滑动窗优化[已接受]"></a>方法＃3滑动窗优化[已接受]</h2><p>上述方法2中解决方案最多需要2n步。 事实上，它可以被优化，只需要n个步骤。 我们可以定义一个字符与其索引的映射，而不是使用一个字符来判断一个字符是否存在。 然后，当我们发现重复的字符时，我们可以立即跳过这些字符。</p><p>原因是如果s[j]在索引j的范围[i，j）中具有重复，重复的这个索引为j’，我们不需要一点一点地增加i。 我们可以跳过[i，j’]范围内的所有元素,直接令i=j’+ 1。</p><ul><li>Java代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更优代码</li></ul><p>假设字符集为ASCII 128</p><p>以前的实现都没有对字符串的字符集的假设。</p><p>如果我们知道字符集相当小，我们可以将整数数组替换为直接访问表。</p><p>常用的表格有：</p><ul><li>int[26] 用于’a’-‘z’以及’A’-‘Z’</li><li>int[128] 用于ASCII集</li><li>int[256] 用于ASCII扩展集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析</li></ul><p>时间复杂度：O(n)<br>Hashmap空间复杂度：O(min(m,n))<br>Table方式空间复杂度：O(m) m表示字符集的大小</p><p>原文地址：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，找到最长子串的长度，而不重复字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h1&gt;&lt;p&gt;给定“abcabcbb”，答案是“abc”，长度为3。&lt;/p&gt;
&lt;p&gt;给定“bbbbb”，答案是“b”，长度为1。&lt;/p&gt;
&lt;p&gt;给定“pwwkew”，答案是“wke”，长度为3.请注意，答案必须是子字符串，“pwke”是子序列而不是子字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.lpnote.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.lpnote.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.lpnote.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode算法4_两排序数组求中位平均数</title>
    <link href="http://www.lpnote.com/2017/09/07/leetcode-4-median-of-two-sorted-arrays/"/>
    <id>http://www.lpnote.com/2017/09/07/leetcode-4-median-of-two-sorted-arrays/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有两个排序的数组nums1和nums2分别为m和n大小。</p><p>找到两个排序数组的中位数。 整体运行时间复杂度应为O（log（m + n））。</p><p>示例1：<br>nums1 = [1,3]<br>nums2 = [2]</p><p>中位数为2.0<br>示例2：<br>nums1 = [1,2]<br>nums2 = [3,4]</p><p>中位数为（2 + 3）/ 2 = 2.5</p><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题中的中位数是指对于一个长度为n的数组，如果n为偶数，则中位数为下标为n/2和n/2+1的两数相加取平均值；如果n为奇数，则中位数为下标为n/2+1的数。</p><p>对于两个数组，我们知道合并成一个数组后，同样适用上面的方式。所以我们可以根据上面的描述确定对于两个数组遍历得到的中位数下标，同时我们定义一个计数器，以确定在按序遍历时的计数，当计数与我们确定的中位数下标达到一致状态时，即可确定我们的中位数。</p><p>本题中主要关注已排序这个前提条件，我们可以使用两个指针分别指向两个数组的头部（数组下标为0的位置），两个指针对应的数进行比较得出较小值，将计数器与预计算的中位数的下标进行对比，判断是否达到中位数下标，最后累加计数器。</p><h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1 = <span class="number">0</span>,idx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx1Max = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> idx2Max = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> total = idx1Max + idx2Max;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] middles = (total % <span class="number">2</span>) == <span class="number">0</span> ? (<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;total / <span class="number">2</span>,total / <span class="number">2</span> + <span class="number">1</span>&#125; ) : (<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;total / <span class="number">2</span> + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> median = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(idx1 &lt; idx1Max || idx2 &lt; idx2Max)&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx1 &lt; idx1Max &amp;&amp; idx2 &lt; idx2Max)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[idx1] &gt; nums2[idx2])&#123;</span><br><span class="line">                    num = nums2[idx2];</span><br><span class="line">                    idx2++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    num = nums1[idx1];</span><br><span class="line">                    idx1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx1 &gt;= idx1Max &amp;&amp; idx2 &lt; idx2Max)&#123;</span><br><span class="line">                num = nums2[idx2];</span><br><span class="line">                idx2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx1 &lt; idx1Max &amp;&amp; idx2 &gt;= idx2Max)&#123;</span><br><span class="line">                num = nums1[idx1];</span><br><span class="line">                idx1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't reach here"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(middles.length == <span class="number">1</span> &amp;&amp; counter == middles[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">double</span>) num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(middles.length == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(counter == middles[<span class="number">0</span>])&#123;</span><br><span class="line">                    median += num;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(counter == middles[<span class="number">1</span>])&#123;</span><br><span class="line">                    median += num;</span><br><span class="line">                    <span class="keyword">return</span> (<span class="keyword">double</span>) median / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            counter++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>空间复杂度：O（1），没有使用额外的空间用于计算，只有一些变量值，空间忽略。<br>时间复杂度：O(log(m+n))，因在一般情况下对于两个数组基本确定在遍历到一半的情况下都能找到结果，故在m+n两数组总长度与计算耗时上存在2的倍数关系，故为O(log(m+n))。</p><p>原文地址：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有两个排序的数组nums1和nums2分别为m和n大小。&lt;/p&gt;
&lt;p&gt;找到两个排序数组的中位数。 整体运行时间复杂度应为O（log（m + n））。&lt;/p&gt;
&lt;p&gt;示例1：&lt;br&gt;nums1 = [1,3]&lt;br&gt;nums2 = [2]&lt;/p&gt;
&lt;p&gt;中位数为2.0&lt;br&gt;示例2：&lt;br&gt;nums1 = [1,2]&lt;br&gt;nums2 = [3,4]&lt;/p&gt;
&lt;p&gt;中位数为（2 + 3）/ 2 = 2.5&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.lpnote.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.lpnote.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.lpnote.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode算法题2_两数相加</title>
    <link href="http://www.lpnote.com/2017/09/06/leetcode-2-add-two-numbers/"/>
    <id>http://www.lpnote.com/2017/09/06/leetcode-2-add-two-numbers/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。</p><p>您可以假设两个数字不包含任何前导零，除了数字0本身。</p><a id="more"></a><p>思路：</p><p>参考常规的两数相加算式以及进位思想，两数相加与10相除得到该位相加后数值，两数相加与10取余得到该位相加后进位数。</p><p>方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode root = <span class="keyword">null</span>;</span><br><span class="line">        ListNode parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode n1 = l1;</span><br><span class="line">        ListNode n2 = l2;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//在此情况下两个数各个位数都已经相加完成，只剩最后的进位数</span></span><br><span class="line">                <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">                    ListNode child = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">                    parent.next = child;</span><br><span class="line">                    parent = child;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                val = n1.val + n2.val + carry;</span><br><span class="line">                carry = val / <span class="number">10</span>;</span><br><span class="line">                val = val % <span class="number">10</span>;</span><br><span class="line">                n1 = n1.next;</span><br><span class="line">                n2 = n2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1 == <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                val = n2.val + carry;</span><br><span class="line">                carry = val / <span class="number">10</span>;</span><br><span class="line">                val = val % <span class="number">10</span>;</span><br><span class="line">                n1 = <span class="keyword">null</span>;</span><br><span class="line">                n2 = n2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                val = n1.val + carry;</span><br><span class="line">                carry = val / <span class="number">10</span>;</span><br><span class="line">                val = val % <span class="number">10</span>;</span><br><span class="line">                n1 = n1.next;</span><br><span class="line">                n2 = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                parent = root;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode child = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">                parent.next = child;</span><br><span class="line">                parent = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文地址：<a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2. Add Two Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个非空的链表，表示两个非负整数。 数字以相反的顺序存储，每个节点包含一个数字。 添加两个数字并将其作为链表返回。&lt;/p&gt;
&lt;p&gt;您可以假设两个数字不包含任何前导零，除了数字0本身。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.lpnote.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.lpnote.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.lpnote.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode算法题167_两数之和（II）</title>
    <link href="http://www.lpnote.com/2017/09/06/leetcode-two-sum-part-2/"/>
    <id>http://www.lpnote.com/2017/09/06/leetcode-two-sum-part-2/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2019-02-13T08:59:06.532Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个已经按升序排序的整数数组，找到两个数字，使它们相加到一个特定的目标数。</p><p>函数twoSum应该返回两个数字的索引，使它们相加到目标，其中index1必须小于index2。 请注意，您返回的答案（index1和index2）都不是基于零的。</p><p>您可以假设每个输入都将具有一个解决方案，您可能不会使用相同的元素两次。</p><p>输入：numbers = {2，7，11，15}，target = 9<br>输出：index1 = 1，index2 = 2</p><a id="more"></a><p>方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;++i)&#123;</span><br><span class="line">            indexMap.put(numbers[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;++i)&#123;</span><br><span class="line">            Integer idx = indexMap.get(target-numbers[i]);</span><br><span class="line">            <span class="keyword">if</span>(idx != <span class="keyword">null</span> &amp;&amp; i != idx)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,idx+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题同时可见：<a href="/leetcode-two-sum/">leetcode算法题1_两数之和</a></p><p>原文地址：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个已经按升序排序的整数数组，找到两个数字，使它们相加到一个特定的目标数。&lt;/p&gt;
&lt;p&gt;函数twoSum应该返回两个数字的索引，使它们相加到目标，其中index1必须小于index2。 请注意，您返回的答案（index1和index2）都不是基于零的。&lt;/p&gt;
&lt;p&gt;您可以假设每个输入都将具有一个解决方案，您可能不会使用相同的元素两次。&lt;/p&gt;
&lt;p&gt;输入：numbers = {2，7，11，15}，target = 9&lt;br&gt;输出：index1 = 1，index2 = 2&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://www.lpnote.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://www.lpnote.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://www.lpnote.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
